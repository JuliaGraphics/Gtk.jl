<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality · Gtk.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gtk.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gtk.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/gettingStarted/">Getting Started</a></li><li><a class="tocitem" href="../../manual/properties/">Properties</a></li><li><a class="tocitem" href="../../manual/layout/">Layout</a></li><li><a class="tocitem" href="../../manual/signals/">Signals and Callbacks</a></li><li><a class="tocitem" href="../../manual/builder/">Builder and Glade</a></li><li><a class="tocitem" href="../../manual/textwidgets/">Text Widgets</a></li><li><a class="tocitem" href="../../manual/combobox/">Combobox</a></li><li><a class="tocitem" href="../../manual/listtreeview/">List and Tree Widgets</a></li><li><a class="tocitem" href="../../manual/filedialogs/">Dialogs</a></li><li><a class="tocitem" href="../../manual/keyevents/">Key Events</a></li><li><a class="tocitem" href="../../manual/canvas/">Drawing on Canvas</a></li><li><a class="tocitem" href="../../manual/customWidgets/">Custom/Composed Widgets</a></li><li><a class="tocitem" href="../../manual/slider/">Slider widgets (aka GtkScale) and dynamic adjustments</a></li><li><a class="tocitem" href="../../manual/async/">Asynchronous UI</a></li><li><a class="tocitem" href="../../manual/nonreplusage/">Non REPL Usage</a></li><li><a class="tocitem" href="../../manual/packages/">High-Level Packages</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphics/Gtk.jl/blob/master/docs/src/doc/developer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Gtk-Developer-Oriented-Documentation:-Extending-Gtk.jl’s-functionality-1"><a class="docs-heading-anchor" href="#Gtk-Developer-Oriented-Documentation:-Extending-Gtk.jl’s-functionality-1">Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality</a><a class="docs-heading-anchor-permalink" href="#Gtk-Developer-Oriented-Documentation:-Extending-Gtk.jl’s-functionality-1" title="Permalink"></a></h1><hr/><h2 id="Implementing-New-Gtk-Types-1"><a class="docs-heading-anchor" href="#Implementing-New-Gtk-Types-1">Implementing New Gtk Types</a><a class="docs-heading-anchor-permalink" href="#Implementing-New-Gtk-Types-1" title="Permalink"></a></h2><p>You can subclass an existing Gtk type in Julia using the following code pattern:</p><pre><code class="language-none">type MyWidget &lt;: Gtk.GtkButton
    handle::Ptr{Gtk.GObject}
    other_fields
    function MyWidget(label)
        btn = @GtkButton(label)
        Gtk.gobject_move_ref(new(btn), btn)
    end
end</code></pre><p>This creates a <code>MyWidget</code> type which inherits its behavior from <code>GtkButton</code>. The <code>gobject_move_ref</code> call transfers ownership of the <code>GObject</code> handle from <code>GtkButton</code> to <code>MyWidget</code> in a gc-safe manner. Afterwards, the <code>btn</code> object is invalid and converting from the <code>Ptr{GtkObject}</code> to <code>GtkObject</code> will return the <code>MyWidget</code> object.</p><p>New native Gtk types can be most easily added by invoking the <code>Gtk.@GTypes</code> macro:</p><pre><code class="language-none"> Gtk.@GTypes GTypeName library_variable sym_name
 Gtk.@GTypes GTypeName library_variable gtyp_getter_expr</code></pre><p>and then defining the appropriate outer constructors. Note that the <code>@GTypes</code> macro expects a variable <code>suffix</code> to be defined in the current module, which will be appended to the name of the type to create a unique type instance.</p><p>Please pay attention to existing constructors that already exist to avoid user confusion: for example, the first argument to a <code>GtkContainer</code> may optionally be its first child widget. And keyword arguments are reserved for setting properties after construction.</p><hr/><h2 id="Utility-functions-1"><a class="docs-heading-anchor" href="#Utility-functions-1">Utility functions</a><a class="docs-heading-anchor-permalink" href="#Utility-functions-1" title="Permalink"></a></h2><h3 id="GLib.bytestring(ptr,-own::Bool)-1"><a class="docs-heading-anchor" href="#GLib.bytestring(ptr,-own::Bool)-1"><code>GLib.bytestring(ptr, own::Bool)</code></a><a class="docs-heading-anchor-permalink" href="#GLib.bytestring(ptr,-own::Bool)-1" title="Permalink"></a></h3><p>This no-copy variant of <code>bytestring</code> allows you to specify whether Julia &quot;owns&quot; the memory pointed to by <code>ptr</code> (similar to <code>Base.pointer_to_array</code>). This is useful for <code>GList</code> iteration when wishing to return strings created by a Gtk object, and other APIs that return a newly allocated string.</p><h3 id="GLib.gc_ref(x::ANY)-/-GLib.gc_unref(x::ANY)-/-GLib.gobject_ref(x::GObject)-1"><a class="docs-heading-anchor" href="#GLib.gc_ref(x::ANY)-/-GLib.gc_unref(x::ANY)-/-GLib.gobject_ref(x::GObject)-1"><code>GLib.gc_ref(x::ANY)</code> / <code>GLib.gc_unref(x::ANY)</code> / <code>GLib.gobject_ref(x::GObject)</code></a><a class="docs-heading-anchor-permalink" href="#GLib.gc_ref(x::ANY)-/-GLib.gc_unref(x::ANY)-/-GLib.gobject_ref(x::GObject)-1" title="Permalink"></a></h3><p>As the names suggests, these functions increase / decrease the reference count of a Julia object <code>x</code>, to prevent garbage-collection of this object while it is in use by <code>Glib</code>. Note that <code>GLib.gc_unref(w::GObject)</code> should typically not be called, since it will immediately destroy the Julia reference <code>w</code>, and will be called automatically by the Julia garbage-collector once their are no remaining references to this object (in GLib or Julia). The function <code>gc_ref</code> returns a pointer to the gc-protected memory (as a <code>*jl_value_t</code> / <code>Ptr{Nothing}</code>) for use in ccall, whereas <code>gobject_ref</code> returns <code>x</code> for use in method chaining.</p><h3 id="mutable{T}(::Type{T})-1"><a class="docs-heading-anchor" href="#mutable{T}(::Type{T})-1"><code>mutable{T}(::Type{T})</code></a><a class="docs-heading-anchor-permalink" href="#mutable{T}(::Type{T})-1" title="Permalink"></a></h3><p>Creates a new box to contain an reference to an instance of <code>T</code></p><h3 id="mutable(x,-i1)-1"><a class="docs-heading-anchor" href="#mutable(x,-i1)-1"><code>mutable(x, i=1)</code></a><a class="docs-heading-anchor-permalink" href="#mutable(x,-i1)-1" title="Permalink"></a></h3><p>Creates a new box (with optional offset index <code>i==1</code>) initialized to contain <code>x</code></p><h3 id="mutable(x::Union{Ptr,Array,Mutable},-i1)-1"><a class="docs-heading-anchor" href="#mutable(x::Union{Ptr,Array,Mutable},-i1)-1"><code>mutable(x::Union{Ptr,Array,Mutable}, i=1)</code></a><a class="docs-heading-anchor-permalink" href="#mutable(x::Union{Ptr,Array,Mutable},-i1)-1" title="Permalink"></a></h3><p>Returns the reference to the box, <code>x</code>, optionally offset by index <code>i</code></p><hr/><h2 id="GLib.MutableTypes-1"><a class="docs-heading-anchor" href="#GLib.MutableTypes-1">GLib.MutableTypes</a><a class="docs-heading-anchor-permalink" href="#GLib.MutableTypes-1" title="Permalink"></a></h2><p>The <code>GLib.MutableTypes</code> module provides methods for seamlessly working with various forms of boxed <code>immutable</code> (or <code>mutable</code>) objects. An immutable object could be boxed in a <code>Ptr</code> and <code>Array</code>, or an <code>MutableTypes.MutableX</code> singleton wrapper. Therefore, the <code>mutable</code> class helps to seamlessly merge all three into a single interface.</p><p>Given a <code>mutable</code> object, the user can extract the data in one of three ways:</p><ul><li>Using <code>[]</code> (<code>getindex</code>) notation is convenient short-hand, but is not defined for pointers</li><li>If the <code>mutable</code> object reference might be a pointer, instead choose either of the <code>deref</code> or <code>unsafe_load</code> function names. Their behavior is identical for the types in the <code>MutableTypes</code> module, but they might have had different fallback methods added externally.</li></ul><p>Updating the value is a <code>mutable</code> object reference can also be done in one of three ways:</p><ul><li>By passing the mutable object to <code>ccall</code>, with type signature <code>Ptr{T}</code></li><li>Using <code>[] =</code> (<code>setindex!</code>) is convenient short-hand notation, but is not defined for pointers</li><li>If the <code>mutable</code> object reference might be a pointer, instead call <code>unsafe_store!</code></li></ul><hr/><h2 id="GLists-1"><a class="docs-heading-anchor" href="#GLists-1">GLists</a><a class="docs-heading-anchor-permalink" href="#GLists-1" title="Permalink"></a></h2><h3 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h3><p>Gtk functions that return a <code>GLib.GList</code> can be used in Julia&#39;s iteration syntax in the following way:</p><pre><code class="language-none">for obj in ccall((:gtk_function_that_returns_a_GList,libgtk),
        Ptr{_GSList{T}}, (ArgTypes...,), args...)
    # do something with obj
end</code></pre><h3 id="Return-Type-1"><a class="docs-heading-anchor" href="#Return-Type-1">Return Type</a><a class="docs-heading-anchor-permalink" href="#Return-Type-1" title="Permalink"></a></h3><p>The returned instance <code>obj</code> will be of type <code>eltype(_GSList{T})</code>, where for <code>T</code> you have picked the expected element return type. See <a href="#glist-eltype-representations">below</a> for more details on the storage characteristics for various choices of <code>T</code></p><h3 id="GC-Safety-1"><a class="docs-heading-anchor" href="#GC-Safety-1">GC Safety</a><a class="docs-heading-anchor-permalink" href="#GC-Safety-1" title="Permalink"></a></h3><p>Depending on where you acquired your <code>GLib.GList</code>, you will need to select the appropriate method to provide seamless garbage-collection integration.</p><ol><li>A naked <code>ptr=Ptr{_GSList{T}}</code> is never garbage-collected by Julia. This is useful when iterating over a <code>GLib.GSList</code> (or <code>GLib.GList</code>) from <code>GLib</code> which still owned by the object <code>[transfer-none]</code></li><li>Wrapping the pointer in a call to <code>GLib.GList(ptr)</code> will free the list when the returned <code>GList</code> object reference is garbage-collected <code>[transfer-container]</code></li><li>Wrapping the pointer instead in a call to <code>glist_iter(ptr)</code> will wrap the list in GC-safe iterator. By contrast to calling <code>GLib.GList(ptr)</code>, this method is necessary if the user is unlikely to be able to maintain the a reference to the returned object for the life of the iterator. Instances where this is true include iterators (hence the name), since this function is often used to create iterators: <code>start(x) = glist_iter(get_ptr_to_glist(x))</code>. <code>[transfer-container]</code></li><li>To both 2 and 3, you can supply an additional boolean parameter <code>transfer-full</code>, to have Julia also dereference and free the individual elements <code>[transfer-full]</code></li><li>WARNING: ensure the choice of <code>_GSList</code> vs <code>_GList</code> matches the Gtk API exactly. Using the wrong one will corrupt the GSlice allocator.</li></ol><h3 id="Julia-allocated-GLists-1"><a class="docs-heading-anchor" href="#Julia-allocated-GLists-1">Julia-allocated GLists</a><a class="docs-heading-anchor-permalink" href="#Julia-allocated-GLists-1" title="Permalink"></a></h3><p>You can create and manipulate a new doubly-linked <code>GList</code> object from Julia by calling the <code>GList(T)</code> constructor, where <code>T</code> is the <code>eltype</code> of the pointers that you want this list to be able to hold.</p><pre><code class="language-none">list = GList(Int) # similar to Array(Int,1)
list[1]</code></pre><p>By default, these are allocated as <code>[transfer-full]</code>, meaning it will deallocate all of its elements when the list is destroyed. However, like all <code>GList</code> constructors, it takes an <code>transfer_full</code> argument, which can be set to false to have Julia reference it as <code>[tranfer-container]</code>.</p><p>To transfer ownership of the GList, you can extract the <code>GList.handle</code> from list, and the set <code>GList.handle = C_NULL</code> to reset it.</p><p>A <code>GList</code> conforms to the <code>AbstractVector</code> interface, and can be used in most contexts that an <code>Array</code> could be used.</p><h3 id="GList-eltype-Representations-1"><a class="docs-heading-anchor" href="#GList-eltype-Representations-1">GList <code>eltype</code> Representations</a><a class="docs-heading-anchor-permalink" href="#GList-eltype-Representations-1" title="Permalink"></a></h3><ul><li><code>GList{T&lt;:GObject} stores references to</code>GObject`</li><li><code>GList{T&lt;:Any}</code> stores Julia object references</li><li><code>GList{T&lt;:Ptr}</code> stores pointers, without alteration</li><li><code>GList{T&lt;:Number}</code> stores numbers inside the pointer (generally only works with Integer, and size must be &lt;= sizeof(int) == 32 bits)</li><li><code>GList{T&lt;:Ptr{Number}}</code> stores individually <code>g_malloc</code>-created boxed numerical type objects</li></ul><p>You can add your own conversions by defining the appropriate <code>eltype  -&gt; return type</code>, <code>GLib.ref_to -&gt; makes a pointer from an object</code>, <code>GLib.deref_to -&gt; makes an object from a pointer</code>, and <code>empty! -&gt; frees the contents of a list object of this type</code> methods (see the bottom of <code>GLib/glist.jl</code> for examples.</p><hr/><h2 id="Adding-new-GValueJulia-auto-conversions-1"><a class="docs-heading-anchor" href="#Adding-new-GValueJulia-auto-conversions-1">Adding new <code>GValue</code>⇄<code>Julia</code> auto-conversions</a><a class="docs-heading-anchor-permalink" href="#Adding-new-GValueJulia-auto-conversions-1" title="Permalink"></a></h2><p>New GValue-to-Julia conversions can be implemented via the <code>Gtk.make_gvalue(pass_x,as_ctype,to_gtype,with_id,allow_reverse::Bool=true)</code> function. This adds all of the appropriate methods to getindex, setindex!, and gvalue to handle converting this value to and from a GValue.</p><ul><li><code>pass_x</code> is the Julia type</li><li><code>as_ctype</code> is the type for ccall</li><li><code>to_gtype</code> is the name of the <code>g_value_get_*</code> <code>g_value_set_*</code> method to use</li><li><code>with_id</code> specifies the type identifier. It must resolve to an Int, but can either be a variable, and Integer, or a tuple of the type name and library where the <code>_get_type</code> function can be called</li><li><code>allow_reverse</code> specifies whether this entry should be used for auto-unpacking</li></ul><p>Note that this calls Core.eval on its arguments in the current module, so if you want to use a symbol from Gtk (such as <code>Gtk.libgtk</code>, make sure you give the fully qualified name). You will also need to ensure the appropriate convert methods exist to translate from <code>pass_x</code> to <code>as_ctype</code> and back. <code>make_gvalue</code> does a few automatic transformations:</p><ul><li>if the <code>to_gtype</code> is <code>:string</code> or <code>:static_string</code>, make_gvalue will insert calls to bytestring</li><li>if the <code>to_gtype</code> is <code>:pointer</code> or <code>:boxed</code>, make_gvalue will insert code (a call to <code>Gtk.mutable</code>) that converts from <code>Type</code> -&gt; <code>Ptr{Type}</code> in the <code>setindex!</code> method. Providing a conversion from <code>Ptr{Type}</code> -&gt; <code>Type</code> must be handled by the user.</li></ul><p>For example:</p><pre><code class="language-none">Gtk.make_gvalue(Gtk.GdkRectangle, Ptr{Gtk.GdkRectangle}, :boxed, (:gdk_rectangle,:(Gtk.libgdk)))
Base.convert(::Type{Gtk.GdkRectangle}, rect::Ptr{Gtk.GdkRectangle}) = unsafe_load(rect)</code></pre></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 27 December 2022 02:02">Tuesday 27 December 2022</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
