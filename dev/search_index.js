var documenterSearchIndex = {"docs":
[{"location":"doc/overview/#Overview-1","page":"-","title":"Overview","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"This Gtk wrapper attempts to expose all of the power of the Gtk library in a simple, uniform interface. The structure and names employed should be easily familiar to anyone browsing the Gtk documentation or example code, or anyone who has prior experience with Gtk.","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"It is always safe to alter the properties of a Gtk object defined in Gtk.jl outside of calling the functions provided therein, such as through another program language, or direct ccall's.","category":"page"},{"location":"doc/overview/#Referring-to-Gtk.Objects-1","page":"-","title":"Referring to Gtk.Objects","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"Gtk object can be referenced by their Gtk names (which almost always have a name like GtkWindow), or their \"short name\" (which is generally just the Gtk name without the \"Gtk\", for example, Window). You can call using Gtk to import the regular names, or using Gtk.ShortNames to import the shorter names. You can also call import Gtk, and then access either the regular or short names (e.g. Gtk.Window or Gtk.GtkWindow).","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"The concrete types are the Gtk object name with a suffix of Leaf appended (to remind the user that this is a \"leaf\" in the Julia type-tree). For example, to refer to the concrete GtkWindow type, the user would write Gtk.GtkWindowLeaf.","category":"page"},{"location":"doc/overview/#Constructing-a-Gtk.@Object-1","page":"-","title":"Constructing a Gtk.@Object","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"Gtk object constructors (by convention), are the name of the Gtk object (interface) name, with a suffix of Leaf appended. For example, to construct a new window, the user would invoke Gtk.WindowLeaf().","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Alternatively, the user can use the macro form of the widget name to construct a new GObject, as shown in the example below.","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"All object constructors accept keyword arguments to set object properties. These arguments are forwarded to the corresponding set_gtk_property! method (see below).","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"w = @GtkWindow(title=\"Hello World\")","category":"page"},{"location":"doc/overview/#Objects-are-containers-for-their-[child_elements...]-1","page":"-","title":"Objects are containers for their [child_elements...]","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"All objects in Gtk are intended to behave uniformly. This means that all objects will try to act as container objects for whatever they 'contain'. Indexing into an object (by number), or iterating the object will return a list of its contents or child objects. This also means that constructors are called with information on the elements that they contain. For example, when you create a button, you can specify either the embedded text or another widget!","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Gtk.@Button(\"This is a button\")\nGtk.@Button(Gtk.@Label(\"Click me\"))","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"On the flip side, you can assign child widgets to indices, or push! them onto the list of child widgets, for any object which derives from a GtkContainer. Of special note is the anti-object GtkNullContainer or simply Null. This is not actually a GObject. However, it can be used to prevent the creation of a default container, and it has the special behavior that it will remove any object added to it from its existing parent (although standard operations like splice! and delete! also exist, and are typically preferable for readability).","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"The optimal pattern for creating objects generally depends upon the usage. However, you may find the following pattern useful for creating layout hierarchies:","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"w=Gtk.@Window() |>\n    (f=Gtk.@Box(:h) |>\n        (b=Gtk.@Button(\"1\")) |>\n        (c=Gtk.@Button(\"2\")) |>\n        (f2=Gtk.@Box(:v) |>\n            Gtk.@Label(\"3\") |>\n            Gtk.@Label(\"4\"))) |>\n    showall","category":"page"},{"location":"doc/overview/#Objects-have-get*gtk*property(obj,-:prop,-types)-and-set*gtk*property!(obj,-:prop,-value)-1","page":"-","title":"Objects have getgtkproperty(obj, :prop, types) and setgtkproperty!(obj, :prop, value)","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":" > warning: this API uses 0-based indexing","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"The properties of any object can be accessed by via the get_gtk_property and set_gtk_property! methods. Displaying a GtkObject at the REPL-prompt will show you all of the properties that can be set on the object. Or you can view the Gtk documentation online. Indexing is typically done using a symbol, but you can also use a string. In property names, you can replace - with _ as shown below.","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"When retrieving a property, you must specify the output type. Specifying the input type when setting a property is strictly optional.","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Some Examples:","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"w = @GtkWindow(\"Title\")\nshow(STDOUT, w) # without the STDOUT parameter, show(w) would\n                # make the window visible on the screen, instead\n                # of printing the information in the REPL\nget_gtk_property(w,:title,String)\nset_gtk_property!(w,:title,\"New title\")\nset_gtk_property!(w,:urgency_hint,Bool,true)","category":"page"},{"location":"doc/overview/#Objects-can-signal-events-1","page":"-","title":"Objects can signal events","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"There are two entry points to the API for handling signals: Simple and robust OR fast and precise.","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"You can remove signal handlers by their id using signal_handler_disconnect or temporarily block them by id using signal_handler_block and signal_handler_unblock","category":"page"},{"location":"doc/overview/#Easy-Event-Handlers-1","page":"-","title":"Easy Event Handlers","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"Upon entry to the signal handler, Julia will unpack the arguments it received into native types:","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"id = signal_connect(widget, :event) do obj, args...\n    println(\"That tickles: $args\")\n    nothing\nend","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"See section on Extending Gtk's Functionality with new GValue<->Julia auto-conversions at the end of this document for details on the auto-unpacking implementation.","category":"page"},{"location":"doc/overview/#Fast-Event-Handlers-1","page":"-","title":"Fast Event Handlers","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"If you want pre-optimized event handlers, you will need to specify the interface types when creating the signal handlers. (There are a few on_signal_ convenience functions which do this, often in conjunction with setting other flags needed for the signal handler to function). You will often find it necessary to refer to the Gtk documentation for the signals API for Gtk callbacks:","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Gtk+ 2\nGtk2 Object Closures\nGtk2 Widget Closures\nGtk+ 3\nGtk3 Widget Closures","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Note that the ArgType argument only specifies the type for the middle arguments. The type of the first and last arguments are determined automatically.","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Example:","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"function on_signal_event(ptr, args, widget)\n    println(\"That tickles\")\n    nothing\nend\nid = signal_connect(widget, :event, Nothing, (ArgType,))\n## OR\nid = signal_connect(widget, :event, Nothing, (ArgType,)) do ptr, args, obj\n    println(\"That tickles\")\n    nothing\nend","category":"page"},{"location":"doc/overview/#Events-can-be-emitted-1","page":"-","title":"Events can be emitted","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"In addition to listening for events, you can trigger your own:","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"#syntax: signal_emit(w::GObject, sig::Union{String,Symbol}, RT::Type, args...)\nsignal_emit(widget, :event, Nothing, 42)","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Note: the return type and argument types do not need to match the spec. However, the length of the args list MUST exactly match the length of the ArgType's list.","category":"page"},{"location":"doc/overview/#Objects-have-get-and-set-accessor-methods-1","page":"-","title":"Objects have get and set accessor methods","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"> warning: this API has not been completely finalized\n> warning: this API uses 0-based indexing\n> note: this API will likely be exposed in a later version as ``Window[:title] = \"My Title\"``, ``Window[:title,String]``","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Gtk_ (not exported), GtkG_ (exported by Gtk.ShortNames), and GtkGAccessor (exported by Gtk) all refer to the same module: a collection of auto-generated method stubs for calling get/set methods on the GObject's. The difference between a get and set method is based upon the number of arguments.","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Example usage:","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"bytestring(Gtk._.title(WindowLeaf(\"my title\")))\nG_.title(WindowLeaf(\"my title\"), \"my new title\")\nGAccessor.size(WindowLeaf(\"what size?\"))","category":"page"},{"location":"doc/overview/#","page":"-","title":"-","text":"Note that because these are auto-generated, you will often need to do your own gc-management at the interface. For example, the string returned by title must not be freed or modified. Since the code auto-generator cannot know this, it simply returns the raw pointer.","category":"page"},{"location":"doc/overview/#Constants-1","page":"-","title":"Constants","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"Interaction with Gtk sometimes requires constants, which are bundled into the Gtk.GConstants module. GConstants in turn contains modules corresponding to each Gtk enum type. For example, constants corresponding to the GdkEventMask are in Gtk.GConstants.GdkEventMask. Each constant can be referred to by its full Gtk name or by a shortened name, for example GDK_KEY_PRESS_MASK can also be used as KEY_PRESS. The rule for generating the shortened name is that any prefix common to the entire enum is stripped off, as well as any trailing _MASK if that ending is common to all elements in the enum.","category":"page"},{"location":"doc/overview/#Gtk-Object-Tree-1","page":"-","title":"Gtk Object Tree","text":"","category":"section"},{"location":"doc/overview/#","page":"-","title":"-","text":"+- Any\n.  +- AbstractArray = AbstractArray{GValue,1}\n.  .  +- MatrixStrided = MatrixStrided{T}\n.  .  +- Ranges = Ranges{T}\n.  .  .  +- GtkTextRange\n.  +- GError\n.  +- GObject\n.  .  +- GObjectLeaf{Name}\n.  .  +- GdkPixbuf\n.  .  +- GtkStatusIcon\n.  .  +- GtkTextBuffer\n.  .  +- GtkTextMark\n.  .  +- GtkTextTag\n.  .  +- GtkWidget\n.  .  .  +- GtkCanvas\n.  .  .  +- GtkComboBoxText\n.  .  .  +- GtkContainer\n.  .  .  .  +- GtkBin\n.  .  .  .  .  +- GtkAlignment\n.  .  .  .  .  +- GtkAspectFrame\n.  .  .  .  .  +- GtkButton\n.  .  .  .  .  +- GtkCheckButton\n.  .  .  .  .  +- GtkExpander\n.  .  .  .  .  +- GtkFrame\n.  .  .  .  .  +- GtkLinkButton\n.  .  .  .  .  +- GtkRadioButton\n.  .  .  .  .  +- GtkToggleButton\n.  .  .  .  .  +- GtkVolumeButton\n.  .  .  .  .  +- GtkWindow\n.  .  .  .  .  .  +- GtkDialog\n.  .  .  .  .  .  .  +- GtkFileChooserDialog\n.  .  .  .  +- GtkBox\n.  .  .  .  .  +- GtkButtonBox\n.  .  .  .  .  +- GtkStatusbar\n.  .  .  .  +- GtkGrid\n.  .  .  .  +- GtkLayout\n.  .  .  .  +- GtkNotebook\n.  .  .  .  +- GtkNullContainer\n.  .  .  .  +- GtkOverlay\n.  .  .  .  +- GtkPaned\n.  .  .  .  +- GtkRadioButtonGroup\n.  .  .  .  +- GtkTable\n.  .  .  +- GtkEntry\n.  .  .  +- GtkImage\n.  .  .  +- GtkLabel\n.  .  .  +- GtkProgressBar\n.  .  .  +- GtkScale\n.  .  .  +- GtkSpinButton\n.  .  .  +- GtkSpinner\n.  .  .  +- GtkSwitch\n.  .  .  +- GtkTextView\n.  .  +- GtkNativeDialog\n.  .  .  +- GtkFileChooserNative\n.  +- GParamSpec\n.  +- GSList{T}\n.  +- GValue\n.  +- GdkEvent\n.  .  +- GdkEventAny\n.  .  +- GdkEventButton\n.  .  +- GdkEventCrossing\n.  .  +- GdkEventKey\n.  .  +- GdkEventMotion\n.  .  +- GdkEventScroll\n.  +- GdkPoint\n.  +- GdkRectangle\n.  +- GtkTextIter\n.  +- MouseHandler\n.  +- RGB\n.  +- RGBA","category":"page"},{"location":"manual/async/#Asynchronous-UI-1","page":"Asynchronous UI","title":"Asynchronous UI","text":"","category":"section"},{"location":"manual/async/#","page":"Asynchronous UI","title":"Asynchronous UI","text":"It is possible to perform background computation without interfering with user interface responsiveness either using multithreading or using separate processes. Use of a separate process includes slightly more overhead but also enusres user interface responsiveness more robustly.","category":"page"},{"location":"manual/async/#","page":"Asynchronous UI","title":"Asynchronous UI","text":"Here is an example using threads. Notice that this example will freeze the UI during computation unless Julia is run with two or more threads (julia -t2 on the command line).","category":"page"},{"location":"manual/async/#","page":"Asynchronous UI","title":"Asynchronous UI","text":"using Gtk\n\nbtn = GtkButton(\"Start\")\nsp = GtkSpinner()\nent = GtkEntry()\n\ngrid = GtkGrid()\ngrid[1,1] = btn\ngrid[2,1] = sp\ngrid[1:2,2] = ent\n\nsignal_connect(btn, \"clicked\") do widget\n    start(sp)\n    Threads.@spawn begin\n\n        # Do work\n        stop_time = time() + 3\n        counter = 0\n        while time() < stop_time\n            counter += 1\n        end\n\n        # Interacting with GTK from a thread other than the main thread is\n        # generally not allowed, so we register an idle callback instead.\n        Gtk.GLib.g_idle_add(nothing) do user_data\n            stop(sp)\n            set_gtk_property!(ent, :text, \"I counted to $counter in a thread!\")\n            Cint(false)\n        end\n    end\nend\n\nwin = GtkWindow(grid, \"Threads\", 200, 200)\nshowall(win)","category":"page"},{"location":"manual/async/#","page":"Asynchronous UI","title":"Asynchronous UI","text":"Here is an example using a separate process to offload the work. This toy example is fairly straightforward, but things can get more complex if the offloaded task is more complex. See the manual  for details.","category":"page"},{"location":"manual/async/#","page":"Asynchronous UI","title":"Asynchronous UI","text":"using Gtk, Distributed\n\nbtn = GtkButton(\"Start\")\nsp = GtkSpinner()\nent = GtkEntry()\n\ngrid = GtkGrid()\ngrid[1,1] = btn\ngrid[2,1] = sp\ngrid[1:2,2] = ent\n\nid = addprocs(1)[1]\n\nsignal_connect(btn, \"clicked\") do widget\n    start(sp)\n    @async begin\n\n        # Offload work to a separate process and block until it is done.\n        counter = @fetchfrom id begin\n            stop_time = time() + 3\n            counter = 0\n            while time() < stop_time\n                counter += 1\n            end\n            counter\n        end\n\n        # We are still in the main thread so it is okay to directly access widgets\n        stop(sp)\n        set_gtk_property!(ent, :text, \"I counted to $counter in a separate process!\")\n    end\nend\n\nwin = GtkWindow(grid, \"Distributed\", 200, 200)\nshowall(win)","category":"page"},{"location":"manual/customWidgets/#Custom/Composed-Widgets-1","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"","category":"section"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"In practice, one usually has to customize a widget to ones own needs. Furthermore, it is also useful to group widgets together to break up a complete user interface into manageable parts. Both use cases are discussed next.","category":"page"},{"location":"manual/customWidgets/#Custom-Widgets-1","page":"Custom/Composed Widgets","title":"Custom Widgets","text":"","category":"section"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"You can subclass an existing Gtk type in Julia using the following code pattern:","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"mutable struct MyButton <: Gtk.GtkButton\n    handle::Ptr{Gtk.GObject}\n    other_fields\n    function MyButton(label)\n        btn = GtkButton(label)\n        return Gtk.gobject_move_ref(new(btn), btn)\n    end\nend","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"This creates a MyButton type which inherits its behavior from GtkButton. The gobject_move_ref call transfers ownership of the GObject handle from GtkButton to MyButton in a gc-safe manner. Afterwards, the btn object is invalid and converting from the Ptr{GtkObject} to GtkObject will return the MyButton object.","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"Lets use this pattern to create a button that is initialized with a default text \"My Button\". The code would look like this.","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"mutable struct MyButton <: Gtk.GtkButton\n    handle::Ptr{Gtk.GObject}\n\n    function MyButton()\n        btn = GtkButton(\"My Button\")\n        return Gtk.gobject_move_ref(new(btn.handle), btn)\n    end\nend","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"We can now add this button to e.g. a window or any layout container just as if MyButton would be a regular GtkWidget.","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"btn = MyButton()\nwin = GtkWindow(\"Custom Widget\",400,200)\npush!(win, btn)\nshowall(win)","category":"page"},{"location":"manual/customWidgets/#Composed-Widgets-1","page":"Custom/Composed Widgets","title":"Composed Widgets","text":"","category":"section"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"While a pre-initialized button might look like an artificial use cases, the same pattern can be used to develop composed widgets. In that case one will typically subclass from a layout widget such as GtkBox or GtkGrid. Lets for instance build a new composed widget consisting of a text box and a button","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"mutable struct ComposedWidget <: Gtk.GtkBox\n    handle::Ptr{Gtk.GObject}\n    btn # handle to child\n    tv # handle to child\n\n    function ComposedWidget(label)\n        vbox = GtkBox(:v)\n        btn = GtkButton(label)\n        tv = GtkTextView()\n        push!(vbox,btn,tv)\n        set_gtk_property!(vbox,:expand,tv,true)\n        set_gtk_property!(vbox,:spacing,10)\n        w = new(vbox.handle, btn, tv)\n        return Gtk.gobject_move_ref(w, vbox)\n    end\nend\n\nc = ComposedWidget(\"My Button\")\nwin = GtkWindow(\"Composed Widget\",400,200)\npush!(win, c)\nshowall(win)\n","category":"page"},{"location":"manual/customWidgets/#","page":"Custom/Composed Widgets","title":"Custom/Composed Widgets","text":"You will usually store the handles to all subwidgets in the composed type as has been done in the example. This will give you quick access to the child widgets when e.g. callback functions for ComposedWidget are called.","category":"page"},{"location":"manual/workingCI/#Working-CI-1","page":"Working CI","title":"Working CI","text":"","category":"section"},{"location":"manual/workingCI/#","page":"Working CI","title":"Working CI","text":"If you are using Gtk in your code and want to test it on Linux with Travis for example, you'll need to use xvfb-run. In your .travis.yml, add the following:","category":"page"},{"location":"manual/workingCI/#","page":"Working CI","title":"Working CI","text":"addons:\n    apt:\n        packages:\n            - xvfb\n            - xauth\n            - libgtk-3-0\nscript:\n    - if [[ -a .git/shallow ]]; then git fetch --unshallow; fi\n    - if [[ `uname` = \"Linux\" ]]; then TESTCMD=\"xvfb-run julia\"; else TESTCMD=\"julia\"; fi\n    - $TESTCMD -e 'Pkg.clone(pwd());\n        Pkg.build(\"<yourPackage>\");\n        Pkg.test(\"<yourPackage>\"; coverage=true)'","category":"page"},{"location":"manual/workingCI/#","page":"Working CI","title":"Working CI","text":"Where <yourPackage> is the name of the package that uses Gtk.","category":"page"},{"location":"manual/combobox/#Combobox-1","page":"Combobox","title":"Combobox","text":"","category":"section"},{"location":"manual/combobox/#","page":"Combobox","title":"Combobox","text":"The combobox widget allows for selecting an item from a dropdown menu. There are two different flavors of comboboxes. A simple GtkComboBoxText widget and a more powerful and generic GtkComboBox widget. The former is a subtype of the later","category":"page"},{"location":"manual/combobox/#GtkComboBoxText-1","page":"Combobox","title":"GtkComboBoxText","text":"","category":"section"},{"location":"manual/combobox/#","page":"Combobox","title":"Combobox","text":"The following example shows how to fill a GtkComboBoxText with elements and listen on the changed event","category":"page"},{"location":"manual/combobox/#","page":"Combobox","title":"Combobox","text":"using Gtk\n\ncb = GtkComboBoxText()\nchoices = [\"one\", \"two\", \"three\", \"four\"]\nfor choice in choices\n  push!(cb,choice)\nend\n# Lets set the active element to be \"two\"\nset_gtk_property!(cb,:active,1)\n\nsignal_connect(cb, \"changed\") do widget, others...\n  # get the active index\n  idx = get_gtk_property(cb, \"active\", Int)\n  # get the active string \n  # We need to wrap the GAccessor call into a Gtk bytestring\n  str = Gtk.bytestring( GAccessor.active_text(cb) ) \n  println(\"Active element is \\\"$str\\\" at index $idx\")\nend\n\nwin = GtkWindow(\"ComboBoxText Example\",400,200)\npush!(win, cb)\nshowall(win)","category":"page"},{"location":"manual/combobox/#GtkComboBox-1","page":"Combobox","title":"GtkComboBox","text":"","category":"section"},{"location":"manual/combobox/#","page":"Combobox","title":"Combobox","text":"Before you study the generic GtkComboBox you should have studied the section describing the List and Tree Widgets since both have a similar concept and interface.","category":"page"},{"location":"manual/combobox/#","page":"Combobox","title":"Combobox","text":"TODO ","category":"page"},{"location":"manual/listtreeview/#List-and-Tree-Widgets-1","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"","category":"section"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"The GtkTreeView is a very powerful widgets for displaying table-like or hierarchical data. Other than the name might indicate the GtkTreeView is used for both lists and trees.","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"The power of this widget comes with a slightly more complex design that one has to understand when using the widget. The most important thing is that the widget itself does not store the displayed data. Instead there are dedicated GtkListStore and GtkTreeStore containers that will hold the data. The benefit of this approach is that it is possible to decouple the view from the data:","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"The widget automatically updates when adding, removing or editing data from the store\nThe widget can sort its data without modifications in the store\nColumns can be reordered and resized\nFiltering can be used to show only subsets of data","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"We will in the following introduce both widgets based on small and a more complex example.","category":"page"},{"location":"manual/listtreeview/#List-Store-1","page":"List and Tree Widgets","title":"List Store","text":"","category":"section"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Lets start with a very simple example: A table with three columns representing the name, the age and the gender of a person. Each column must have a specific type. Here, we chose to represent the gender using a boolean value where true  represents female and false represents male. We thus initialize the list store using","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"ls = GtkListStore(String, Int, Bool)","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Now we will the store with data","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"push!(ls,(\"Peter\",20,false))\npush!(ls,(\"Paul\",30,false))\npush!(ls,(\"Mary\",25,true))","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"If we want so insert the data at a specific position we can use the insert function","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"insert!(ls, 2, (\"Susanne\", 35, true))","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"You can use ls like a matrix like container. Calling length and size will give you","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"julia> length(ls)\n4\n\njulia> size(ls)\n(4,3)","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Specific element can be be accessed using","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"julia> ls[1,1]\n\"Peter\"\njulia> ls[1,1] = \"Pete\"\n\"Pete\"","category":"page"},{"location":"manual/listtreeview/#List-View-1","page":"List and Tree Widgets","title":"List View","text":"","category":"section"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Now we actually want to display our data. To this end we create a tree view object","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"tv = GtkTreeView(GtkTreeModel(ls))","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Then we need specific renderers for each of the columns. Usually you will only need a text renderer, but in our example we want to display the boolean value using a checkbox.","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"rTxt = GtkCellRendererText()\nrTog = GtkCellRendererToggle()","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Finally we create for each column a TreeViewColumn object","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"c1 = GtkTreeViewColumn(\"Name\", rTxt, Dict([(\"text\",0)]))\nc2 = GtkTreeViewColumn(\"Age\", rTxt, Dict([(\"text\",1)]))\nc3 = GtkTreeViewColumn(\"Female\", rTog, Dict([(\"active\",2)]))","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"We need to push these column description objects to the tree view","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"push!(tv, c1, c2, c3)","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Then we can display the tree view widget in a window","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"win = GtkWindow(tv, \"List View\")\nshowall(win)","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"If you prefer that the columns are resizable by the user call","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"for c in [c1, c2, c3]\n    GAccessor.resizable(c, true)\nend","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"(Image: listview1)","category":"page"},{"location":"manual/listtreeview/#Sorting-1","page":"List and Tree Widgets","title":"Sorting","text":"","category":"section"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"We next want to make the tree view sortable","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"for (i,c) in enumerate([c1,c2,c3])\n  GAccessor.sort_column_id(c,i-1)\nend","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"If you now click on one of the column headers, the data will be sorted with respect to the selected column. You can even make the columns reorderable","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"for (i,c) in enumerate([c1, c2, c3])\n    GAccessor.reorderable(c, i)\nend","category":"page"},{"location":"manual/listtreeview/#Selection-1","page":"List and Tree Widgets","title":"Selection","text":"","category":"section"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Usually the interesting bit of a list will be the entry being selected. This is done using an additional GtkTreeSelection object that can be retrieved by","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"selection = GAccessor.selection(tv)","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"One either have single selection or multiple selections. We toggle this by calling","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"selection = GAccessor.mode(selection,Gtk.GConstants.GtkSelectionMode.MULTIPLE)","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"We will stick with single selection for now and want to know the index of the selected item","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"julia> ls[selected(selection),1]\n\"Pete\"","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Since it can happen that no item has been selected at all, it is a good idea to put this into an if statement","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"if hasselection(selection)\n  # do something with selected(selection)\nend","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Sometimes you want to invoke an action of an item is selected. This can be done by","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"signal_connect(selection, \"changed\") do widget\n  if hasselection(selection)\n    currentIt = selected(selection)\n\n    # now you can to something with the selected item\n    println(\"Name: \", ls[currentIt,1], \" Age: \", ls[currentIt,1])\n  end\nend","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Another useful signal is \"row-activated\" that will be triggered by a double click of the user.","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"note: Note\ngetting multiple selections still not implemented.","category":"page"},{"location":"manual/listtreeview/#Filtering-1","page":"List and Tree Widgets","title":"Filtering","text":"","category":"section"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"A very useful thing is to apply a filter to a list view such that only a subset of data is shown. We can do this using the GtkTreeModelFilter type. It is as the GtkListStore a GtkTreeModel and therefore we can assign it to a tree view. So the idea is to wrap a GtkListStore in a GtkTreeModelFilter and assign that to the tree view.","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Next question is how to decide which row of the list store should be shown and which shouldn't. We will do this by adding an additional column to the list store that is hidden. The column will be of type Bool and a value true indicates that the entry is to be shown while false indicates the opposite. We make the filtering based on this column by a call to GAccessor.visible_column. The full example now looks like this:","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"using Gtk\n\nls = GtkListStore(String, Int, Bool, Bool)\npush!(ls,(\"Peter\",20,false,true))\npush!(ls,(\"Paul\",30,false,true))\npush!(ls,(\"Mary\",25,true,true))\ninsert!(ls, 2, (\"Susanne\",35,true,true))\n\nrTxt = GtkCellRendererText()\nrTog = GtkCellRendererToggle()\n\nc1 = GtkTreeViewColumn(\"Name\", rTxt, Dict([(\"text\",0)]), sort_column_id=0)\nc2 = GtkTreeViewColumn(\"Age\", rTxt, Dict([(\"text\",1)]), sort_column_id=1)\nc3 = GtkTreeViewColumn(\"Female\", rTog, Dict([(\"active\",2)]), sort_column_id=2)\n\ntmFiltered = GtkTreeModelFilter(ls)\nGAccessor.visible_column(tmFiltered,3)\ntv = GtkTreeView(GtkTreeModel(tmFiltered))\npush!(tv, c1, c2, c3)\n\nselection = GAccessor.selection(tv)\n\nsignal_connect(selection, \"changed\") do widget\n  if hasselection(selection)\n    currentIt = selected(selection)\n\n    println(\"Name: \", GtkTreeModel(tmFiltered)[currentIt,1],\n            \" Age: \", GtkTreeModel(tmFiltered)[currentIt,2])\n  end\nend\n\nent = GtkEntry()\n\nsignal_connect(ent, \"changed\") do widget\n  searchText = get_gtk_property(ent, :text, String)\n\n  for l=1:length(ls)\n    showMe = true\n\n    if length(searchText) > 0\n      showMe = showMe && occursin(lowercase(searchText), lowercase(ls[l,1]))\n    end\n\n    ls[l,4] = showMe\n  end\nend\n\nvbox = GtkBox(:v)\npush!(vbox,ent,tv)\n\nwin = GtkWindow(vbox, \"List View with Filter\")\nshowall(win)","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"You can see that we have added a little search bar such that you can see the filtering in action. It is furthermore important to note that we had to replace ls with GtkTreeModel(tmFiltered) in the selection changed callback since the selection will give an iterator that is only valid in the filtered tree model.","category":"page"},{"location":"manual/listtreeview/#Tree-Widget-1","page":"List and Tree Widgets","title":"Tree Widget","text":"","category":"section"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"Here is an example of the tree model in action:","category":"page"},{"location":"manual/listtreeview/#","page":"List and Tree Widgets","title":"List and Tree Widgets","text":"using Gtk\n\nts = GtkTreeStore(String)\niter1 = push!(ts,(\"one\",))\niter2 = push!(ts,(\"two\",),iter1)\niter3 = push!(ts,(\"three\",),iter2)\ntv = GtkTreeView(GtkTreeModel(ts))\nr1 = GtkCellRendererText()\nc1 = GtkTreeViewColumn(\"A\", r1, Dict([(\"text\",0)]))\npush!(tv,c1)\nwin = GtkWindow(tv, \"Tree View\")\nshowall(win)\n\niter = Gtk.iter_from_index(ts, [1])\nts[iter,1] = \"ONE\"","category":"page"},{"location":"manual/packages/#High-Level-Packages-1","page":"High-Level Packages","title":"High-Level Packages","text":"","category":"section"},{"location":"manual/packages/#","page":"High-Level Packages","title":"High-Level Packages","text":"Finally, there are higher-level wrappers that might simplify your usage of Gtk, such as GtkReactive.","category":"page"},{"location":"doc/OldPartsFromReadme/#Adding-and-removing-objects-1","page":"-","title":"Adding and removing objects","text":"","category":"section"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Many widgets in Gtk can act as containers: for example, windows contain other widgets. New objects are created in \"isolation,\" and attached to their parent containers using push!.","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"For example, let's add a frame:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    f = @Frame(\"A frame\")","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"If you check your window, you won't see anything. That's because the frame has not yet been associated with any container. Let's do that and see what happens:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    push!(win, f)\n    showall(win)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"(Image: window)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Note the showall, which is required to get the display to update with your changes. In some of the examples below, we'll omit this step, but you should call showall any time you want to see the window in its current state.","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Let's add a button:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    ok = @Button(\"OK\")\n    push!(f, ok)\n    showall(win)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"(Image: window)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"We can remove our ok button from the frame:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    delete!(f, ok)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"(You can verify that it doesn't show in the window anymore.) However, ok still exists, and you can put it somewhere else if you wish.","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"\"Container\" objects can also be initialized to contain a child:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    ok = @Button(\"OK\")\n    frame = @Frame(ok, \"A frame\")\n    win = @Window(frame, \"My window\")","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"This only works to add a single (or the first) child of a container.","category":"page"},{"location":"doc/OldPartsFromReadme/#Inspecting-and-manipulating-the-graphics-hierarchy-1","page":"-","title":"Inspecting and manipulating the graphics hierarchy","text":"","category":"section"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"We can get the parent object:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    julia> parent(hbox)\n    GtkFrameLeaf(name=...","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Calling parent on a top-level object yields an error, but you can check to see if the object has a parent using hasparent.","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Likewise, it's possible to get the children:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    for child in hbox\n        println(get_gtk_property(child,:label,String))\n    end","category":"page"},{"location":"doc/OldPartsFromReadme/#Specific-graphical-elements-1","page":"-","title":"Specific graphical elements","text":"","category":"section"},{"location":"doc/OldPartsFromReadme/#Scales-1","page":"-","title":"Scales","text":"","category":"section"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Above we showed how to create a Scale (slider) object. If you examine the Scale's properties, you might be surprised to not see any that deal with its value or range of acceptable values. This is because a Scale contains another more basic type, Adjustment, responsible for holding these properties:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    sc = @Scale(false,0:10)   # range in integer steps, from 0 to 10\n    adj = @Adjustment(sc)\n    set_gtk_property!(adj,:upper,11)         # now this scale goes to 11!\n    set_gtk_property!(adj,:value,7)\n    win = @Window(sc,\"Scale\") |> showall","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"(Image: scale)","category":"page"},{"location":"doc/OldPartsFromReadme/#Menus-1","page":"-","title":"Menus","text":"","category":"section"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"In Gtk, the core element is the MenuItem. Let's say we want to create a file menu; we might begin by creating the item:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    file = @MenuItem(\"_File\")","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"The underscore in front of the \"F\" means that we will be able to select this item using Alt+F. The file menu will have items inside of it, of course, so let's create a submenu associated with this item:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    filemenu = @Menu(file)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Now let's populate it with entries:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    new_ = @MenuItem(\"New\")\n    push!(filemenu, new_)\n    open_ = @MenuItem(\"Open\")\n    push!(filemenu, open_)\n    push!(filemenu, @SeparatorMenuItem())\n    quit = @MenuItem(\"Quit\")\n    push!(filemenu, quit)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"Finally, let's place our file item inside another type of menu, the MenuBar:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    mb = @MenuBar()\n    push!(mb, file)  # notice this is the \"File\" item, not filemenu\n    win = @Window(mb, \"Menus\", 200, 40)\n    showall(mb)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"(Image: menu)","category":"page"},{"location":"doc/OldPartsFromReadme/#Popup-menus-1","page":"-","title":"Popup menus","text":"","category":"section"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"We can create a canvas that, when right clicked, reveals a context menu:","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"    using Gtk.ShortNames, Base.Graphics\n    # Fill a canvas with red\n    c = @Canvas()\n    win = @Window(c, \"Canvas\")\n    draw(c) do widget\n        ctx = getgc(c)\n        set_source_rgb(ctx, 1, 0, 0)\n        paint(ctx)\n    end\n    # Define the popup menu\n    popupmenu = @Menu()\n    printcolor = @MenuItem(\"Print color\")\n    push!(popupmenu, printcolor)\n    push!(popupmenu, @MenuItem(\"Do nothing\"))\n    # This next line is crucial: otherwise your popup menu shows as a thin bar\n    showall(popupmenu)\n    # Associate actions with right-click and selection\n    c.mouse.button3press = (widget,event) -> popup(popupmenu, event)\n    signal_connect(printcolor, :activate) do widget\n        println(\"Red!\")\n    end\n    showall(win)","category":"page"},{"location":"doc/OldPartsFromReadme/#","page":"-","title":"-","text":"(Image: popupmenu)","category":"page"},{"location":"manual/keyevents/#Key-Events-1","page":"Key Events","title":"Key Events","text":"","category":"section"},{"location":"manual/keyevents/#Key-press-events-1","page":"Key Events","title":"Key press events","text":"","category":"section"},{"location":"manual/keyevents/#","page":"Key Events","title":"Key Events","text":"To capture a keyboard event, one can connect to the key-press-event from the active window, as given in the following example.","category":"page"},{"location":"manual/keyevents/#","page":"Key Events","title":"Key Events","text":"using Gtk\n\nwin = GtkWindow(\"Key Press Example\")\n\nsignal_connect(win, \"key-press-event\") do widget, event\n  k = event.keyval\n  println(\"You pressed key \", k, \" which is '\", Char(k), \"'.\")\nend","category":"page"},{"location":"manual/keyevents/#","page":"Key Events","title":"Key Events","text":"You can then check if event.keyval has a certain value and invoke an action in that case.","category":"page"},{"location":"manual/keyevents/#Key-release-events-1","page":"Key Events","title":"Key release events","text":"","category":"section"},{"location":"manual/keyevents/#","page":"Key Events","title":"Key Events","text":"The following example captures the events for both a key press and a key release and reports the time duration between the two. There some state handling here because of the likely event that your keyboard is set to \"repeat\" a pressed key after some initial delay and because it is possilbe to  press multiple keys at once. This version reports the time elapsed between the initial key press and the key release.","category":"page"},{"location":"manual/keyevents/#","page":"Key Events","title":"Key Events","text":"using Gtk\n\nconst start_times = Dict{UInt32, UInt32}()\n\nw = GtkWindow(\"Key Press/Release Example\")\n\nid1 = signal_connect(w, \"key-press-event\") do widget, event\n    k = event.keyval\n    if k ∉ keys(start_times)\n        start_times[k] = event.time # save the initial key press time\n        println(\"You pressed key \", k, \" which is '\", Char(k), \"'.\")\n    else\n        println(\"repeating key \", k)\n    end\nend\n\nid2 = signal_connect(w, \"key-release-event\") do widget, event\n    k = event.keyval\n    start_time = pop!(start_times, k) # remove the key from the dictionary\n    duration = event.time - start_time # key press duration in milliseconds\n    println(\"You released key \", k, \" after time \", duration, \" msec.\")\nend","category":"page"},{"location":"doc/more_signals/#More-about-signals-and-signal-handlers-1","page":"-","title":"More about signals and signal-handlers","text":"","category":"section"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"In addition to the \"simple\" interface, signal_connect supports an approach that allows your callback function to be directly compiled to machine code.  Not only is this more efficient, but it can occasionally be useful in avoiding problems (see issue #161).","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"This alternative syntax is as follows:","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"signal_connect(cb, widget, signalname, return_type, parameter_type_tuple, after, user_data=widget)","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"where:","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"cb is your callback function. This will be compiled with @cfunction, and you need to follow its rules. In particular, you should use a generic function (i.e., one defined as function foo(x,y,z) ... end), and the arguments and return type should match the GTK+ documentation for the widget and signal (see examples). In contrast with the simpler interface, when writing these callbacks you must include the user_data argument.  See examples below.\nwidget is the widget that will send the signal\nsignalname is a string or symbol identifying the signal, e.g., \"clicked\" or \"button-press-event\"\nreturn_type is the type of the value returned by your callback. Usually Nothing (for void) or Cint (for gboolean)\nparameter_type_tuple specifies the types of the middle arguments to the callback function, omitting the first (the widget) and last (user_data).  For example, for \"clicked\" we have parameter_type_tuple = () (because there are no middle arguments) and for \"button-press-event\" we have parameter_type_tuple = (Ptr{GdkEventButton},).\nafter is a boolean, true if you want your callback to run after the default handler for your signal. When in doubt, specify false.\nuser_data contains any additional information your callback needs to operate.  For example, you can pass other widgets, tuples of values, etc.  If omitted, it defaults to widget.","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"The callback's arguments need to match the GTK documentation, with the exception of the user_data argument. (Rather than being a pointer, user_data will automatically be converted back to an object.)","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"For example, consider a GUI in which pressing a button updates a counter:","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"box = @Box(:h)\nbutton = @Button(\"click me\")\nlabel  = @Label(\"0\")\npush!(box, button)\npush!(box, label)\nwin = @Window(box, \"Callbacks\")\nshowall(win)\n\nconst counter = [0]  # Pack counter value inside array to make it a reference\n\n# \"clicked\" callback declaration is\n#     void user_function(GtkButton *button, gpointer user_data)\n# But user_data gets converted into a Julia object automatically\nfunction button_cb(widgetptr::Ptr, user_data)\n     widget = convert(Button, widgetptr)  # pointer -> object\n     lbl, cntr = user_data                # unpack the user_data tuple\n     cntr[] = cntr[]+1                    # increment counter[1]\n     set_gtk_property!(lbl, :label, string(cntr[]))\n     nothing                              # return type is void\nend\n\nsignal_connect(button_cb, button, \"clicked\", Nothing, (), false, (label, counter))","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"You should note that the value of counter[] matches the display in the GUI.","category":"page"},{"location":"doc/more_signals/#Specifying-the-event-type-1","page":"-","title":"Specifying the event type","text":"","category":"section"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"If your callback function takes an event argument, it is important to declare its type correctly. An easy way to do that is to first write a callback using the \"simple\" interface, e.g.,","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"    signal_connect(win, \"delete-event\") do widget, event\n        @show typeof(event)\n        @show event\n    end","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"and then use the reported type in parameter_type_tuple.","category":"page"},{"location":"doc/more_signals/#@guarded-1","page":"-","title":"@guarded","text":"","category":"section"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"The \"simple\" callback interface includes protections against corrupting Gtk state from errors, but this @cfunction-based approach does not. Consequently, you may wish to use @guarded when writing these functions. (Canvas draw functions and mouse event-handling are called through this interface, which is why you should use @guarded there.) For functions that should return a value, you can specify the value to be returned on error as the first argument. For example:","category":"page"},{"location":"doc/more_signals/#","page":"-","title":"-","text":"    const unhandled = convert(Int32, false)\n    @guarded unhandled function my_callback(widgetptr, ...)\n        ...\n    end","category":"page"},{"location":"manual/canvas/#Drawing-on-Canvas-1","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"","category":"section"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"Generic drawing is done on a Canvas. You control what appears on this canvas by defining a draw function:","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"using Gtk, Graphics\nc = @GtkCanvas()\nwin = GtkWindow(c, \"Canvas\")\n@guarded draw(c) do widget\n    ctx = getgc(c)\n    h = height(c)\n    w = width(c)\n    # Paint red rectangle\n    rectangle(ctx, 0, 0, w, h/2)\n    set_source_rgb(ctx, 1, 0, 0)\n    fill(ctx)\n    # Paint blue rectangle\n    rectangle(ctx, 0, 3h/4, w, h/4)\n    set_source_rgb(ctx, 0, 0, 1)\n    fill(ctx)\nend\nshow(c)","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"This draw function will get called each time the window gets resized or otherwise needs to refresh its display.","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"(Image: canvas)","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"Errors in the draw function can corrupt Gtk's internal state; if this happens, you have to quit julia and start a fresh session. To avoid this problem, the @guarded macro wraps your code in a try/catch block and prevents the corruption. It is especially useful when initially writing and debugging code. See further discussion about when @guarded is relevant.","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"Finally, Canvases have a field called mouse that allows you to easily write callbacks for mouse events:","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"c.mouse.button1press = @guarded (widget, event) -> begin\n    ctx = getgc(widget)\n    set_source_rgb(ctx, 0, 1, 0)\n    arc(ctx, event.x, event.y, 5, 0, 2pi)\n    stroke(ctx)\n    reveal(widget)\nend","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"This will draw a green circle on the canvas at every mouse click. Resizing the window will make them go away; they were drawn on the canvas, but they weren't added to the draw function.","category":"page"},{"location":"manual/canvas/#","page":"Drawing on Canvas","title":"Drawing on Canvas","text":"Note the use of the @guarded macro here, too.","category":"page"},{"location":"doc/reference/#API-Reference-1","page":"Reference","title":"API Reference","text":"","category":"section"},{"location":"doc/reference/#Public-interface-1","page":"Reference","title":"Public interface","text":"","category":"section"},{"location":"doc/reference/#","page":"Reference","title":"Reference","text":"Modules = [Gtk]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = false","category":"page"},{"location":"doc/reference/#Gtk.buffer-Tuple{Union{Gtk.GtkTextIter, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}}}","page":"Reference","title":"Gtk.buffer","text":"buffer(iter::Union{Mutable{GtkTextIter}, GtkTextIter})\n\nReturns the buffer associated with iter.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.create_mark-Tuple{GtkTextBuffer, Any, Union{Gtk.GtkTextIter, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}}, Bool}","page":"Reference","title":"Gtk.create_mark","text":"create_mark(buffer::GtkTextBuffer, mark_name, it::TI, left_gravity::Bool)\ncreate_mark(buffer::GtkTextBuffer, it::TI)\n\nImpements gtk_text_buffer_create_mark.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.place_cursor-Tuple{GtkTextBuffer, Gtk.GtkTextIter}","page":"Reference","title":"Gtk.place_cursor","text":"place_cursor(buffer::GtkTextBuffer, it::GtkTextIter)\nplace_cursor(buffer::GtkTextBuffer, pos::Int)\n\nPlace the cursor at indicated position.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.scroll_to-Tuple{GtkTextView, GtkTextMark, Real, Bool, Real, Real}","page":"Reference","title":"Gtk.scroll_to","text":"scroll_to(view::GtkTextView, mark::GtkTextMark, within_margin::Real,\n               use_align::Bool, xalign::Real, yalign::Real)\n\nscroll_to(view::GtkTextView, iter::TI, within_margin::Real,\n          use_align::Bool, xalign::Real, yalign::Real)\n\nImplements gtk_text_view_scroll_to_mark and gtk_text_view_scroll_to_iter.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.search","page":"Reference","title":"Gtk.search","text":"search(buffer::GtkTextBuffer, str::AbstractString, direction = :forward,\n    flag = GtkTextSearchFlags.GTK_TEXT_SEARCH_TEXT_ONLY)\n\nSearch text str in buffer in direction :forward or :backward starting from the cursor position in the buffer.\n\nReturns a tuple (found, start, stop) where found indicates whether the search was successful and start and stop are GtkTextIters containing the location of the match.\n\n\n\n\n\n","category":"function"},{"location":"doc/reference/#Gtk.select_range-Tuple{GtkTextBuffer, Union{Gtk.GtkTextIter, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}}, Union{Gtk.GtkTextIter, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}}}","page":"Reference","title":"Gtk.select_range","text":"select_range(buffer::GtkTextBuffer, ins::TI, bound::TI)\nselect_range(buffer::GtkTextBuffer, range::GtkTextRange)\n\nSelect the text in buffer accorind to GtkTextIter ins and bound.\n\nImplements gtk_text_buffer_select_range.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.selection_bounds-Tuple{GtkTextBuffer}","page":"Reference","title":"Gtk.selection_bounds","text":"selection_bounds(buffer::GtkTextBuffer)\n\nReturns a tuple (selected, start, stop) indicating if text is selected in the buffer, and if so sets the GtkTextIter start and stop to point to the selected text.\n\nImplements gtk_text_buffer_get_selection_bounds.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.showall-Tuple{Gtk.GtkWidget}","page":"Reference","title":"Gtk.showall","text":"showall(w::Gtk.GtkWidget)\n\nRecursively show a widget, and any child widgets (if the widget is a container).\n\nThis function overrides the visible property in all widgets in the hierarchy. Widgets can be protected from showall by setting the no_show_all property on the object to true.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Private-methods-1","page":"Reference","title":"Private methods","text":"","category":"section"},{"location":"doc/reference/#","page":"Reference","title":"Reference","text":"Modules = [Gtk]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false\nPrivate = true","category":"page"},{"location":"doc/reference/#Gtk.GtkTextIter-Tuple{GtkTextBuffer, Integer}","page":"Reference","title":"Gtk.GtkTextIter","text":"GtkTextIter(text::GtkTextBuffer, char_offset::Integer)\n\nCreates a GtkTextIter with offset char_offset (one-based index).\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Base.skip-Tuple{Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Integer, Symbol}","page":"Reference","title":"Base.skip","text":"skip(iter::Mutable{GtkTextIter}, count::Integer, what::Symbol)\n\nMoves iter according to the operation specified by what and count. Operations are :\n\n:chars (gtk_text_iter_forward_chars)\n:lines (gtk_text_iter_forward_lines)\n:words (gtk_text_iter_forward_word_ends)\n:word_cursor_positions (gtk_text_iter_forward_cursor_positions)\n:sentences (gtk_text_iter_forward_sentence_ends)\n:visible_words (gtk_text_iter_forward_visible_word_ends)\n:visible_cursor_positions (gtk_text_iter_forward_visible_cursor_positions)\n:visible_lines (gtk_text_iter_forward_visible_lines)\n:line_ends (gtk_text_iter_forward_visible_lines)\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Base.skip-Tuple{Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Integer}","page":"Reference","title":"Base.skip","text":"skip(iter::Mutable{GtkTextIter}, count::Integer)\n\nMoves iter count characters. Returns a Bool indicating if the move was successful.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Base.skip-Tuple{Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Symbol}","page":"Reference","title":"Base.skip","text":"skip(iter::Mutable{GtkTextIter}, what::Symbol)\n\nMoves iter according to the operation specified by what. Operations are :\n\n:forward_line (gtk_text_iter_forward_line)\n:backward_line (gtk_text_iter_backward_line)\n:forward_to_line_end (gtk_text_iter_forward_to_line_end)\n:backward_word_start (gtk_text_iter_forward_word_end)\n:forward_word_end (gtk_text_iter_backward_word_start)\n:backward_sentence_start (gtk_text_iter_backward_sentence_start)\n:forward_sentence_end (gtk_text_iter_forward_sentence_end)\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.backward_search-Tuple{Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, AbstractString, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Int32}","page":"Reference","title":"Gtk.backward_search","text":"backward_search(iter::Mutable{GtkTextIter},\n    str::AbstractString, start::Mutable{GtkTextIter},\n    stop::Mutable{GtkTextIter}, limit::Mutable{GtkTextIter}, flag::Int32)\n\nImplements gtk_text_iter_backward_search.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.buffer_to_window_coords","page":"Reference","title":"Gtk.buffer_to_window_coords","text":"buffer_to_window_coords(view::GtkTextView, buffer_x::Integer, buffer_y::Integer, wintype::Integer = 0)\n\nImplements gtk_text_view_buffer_to_window_coords.\n\n\n\n\n\n","category":"function"},{"location":"doc/reference/#Gtk.char_offset-Tuple{Union{Gtk.GtkTextIter, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}}}","page":"Reference","title":"Gtk.char_offset","text":"char_offset(iter::Union{Mutable{GtkTextIter}, GtkTextIter})\n\nReturns the offset of iter (one-based index).\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.enable_eventloop","page":"Reference","title":"Gtk.enable_eventloop","text":"Gtk.enable_eventloop(b::Bool = true)\n\nSet whether Gtk's event loop is running.\n\n\n\n\n\n","category":"function"},{"location":"doc/reference/#Gtk.forward_search-Tuple{Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, AbstractString, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Gtk.GLib.MutableTypes.Mutable{Gtk.GtkTextIter}, Int32}","page":"Reference","title":"Gtk.forward_search","text":"forward_search(iter::Mutable{GtkTextIter},\n    str::AbstractString, start::Mutable{GtkTextIter},\n    stop::Mutable{GtkTextIter}, limit::Mutable{GtkTextIter}, flag::Int32)\n\nImplements gtk_text_iter_forward_search.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.is_eventloop_running-Tuple{}","page":"Reference","title":"Gtk.is_eventloop_running","text":"Gtk.is_eventloop_running()::Bool\n\nCheck whether Gtk's event loop is running.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.pause_eventloop-Tuple{Any}","page":"Reference","title":"Gtk.pause_eventloop","text":"Gtk.pause_eventloop(f; force = false)\n\nPauses the eventloop around a function. Restores the state of the eventloop after pausing. Respects whether Gtk.jl is configured to allow auto-stopping of the eventloop, unless force = true.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.text_iter_at_position-Tuple{GtkTextView, Integer, Integer}","page":"Reference","title":"Gtk.text_iter_at_position","text":"text_iter_at_position(view::GtkTextView, x::Integer, y::Integer)\n\nImplements gtk_text_view_get_iter_at_position.\n\n\n\n\n\n","category":"method"},{"location":"doc/reference/#Gtk.window_to_buffer_coords","page":"Reference","title":"Gtk.window_to_buffer_coords","text":"window_to_buffer_coords(view::Gtk.GtkTextView, window_x::Integer, window_y::Integer, wintype::Integer = 2)\n\nImplements gtk_text_view_window_to_buffer_coords.\n\n\n\n\n\n","category":"function"},{"location":"manual/gettingStarted/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"We start this tutorial with a very simple example that creates an empty window of size 400x200 pixels and adds a button to it","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"using Gtk\n\nwin = GtkWindow(\"My First Gtk.jl Program\", 400, 200)\n\nb = GtkButton(\"Click Me\")\npush!(win,b)\n\nshowall(win)","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"We will now go through this example step by step. First the package is loaded using Gtk statement. Then a window is created using the GtkWindow constructor. It gets as input the window title, the window width, and the window height. Then a button is created using the GtkButton constructor. In order to insert the button into the window we call","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"push!(win,b)","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"Finally, showall(win) will render the entire application on the screen.","category":"page"},{"location":"manual/gettingStarted/#Extended-Example-1","page":"Getting Started","title":"Extended Example","text":"","category":"section"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"We will now extend the example to let the button actually do something. To this end we first define a callback function that will be executed when the user clicks the button. Our callback function is supposed to change the window title of the application","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"function on_button_clicked(w)\n  println(\"The button has been clicked\")\nend","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"What happens when the user clicks the button is that a \"clicked\" signal is emitted. In order to connect this signal to our function on_button_clicked we have to call","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"signal_connect(on_button_clicked, b, \"clicked\")","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"Our full extended example thus looks like:","category":"page"},{"location":"manual/gettingStarted/#","page":"Getting Started","title":"Getting Started","text":"using Gtk\n\nwin = GtkWindow(\"My First Gtk.jl Program\", 400, 200)\n\nb = GtkButton(\"Click Me\")\npush!(win,b)\n\nfunction on_button_clicked(w)\n  println(\"The button has been clicked\")\nend\nsignal_connect(on_button_clicked, b, \"clicked\")\n\nshowall(win)","category":"page"},{"location":"manual/signals/#Signals-and-Callbacks-1","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"","category":"section"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"A button is not much use if it doesn't do anything. Gtk+ uses signals as a method for communicating that something of interest has happened. Most signals will be emitted as a consequence of user interaction: clicking on a button, closing a window, or just moving the mouse. You connect your signals to particular functions to make something happen.","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Let's try a simple example:","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"b = GtkButton(\"Press me\")\nwin = GtkWindow(b, \"Callbacks\")\nshowall(win)\n\nfunction button_clicked_callback(widget)\n    println(widget, \" was clicked!\")\nend\n\nid = signal_connect(button_clicked_callback, b, \"clicked\")","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Here, button_clicked_callback is a callback function, something designed to be called by GTK+ to implement the response to user action.  You use the signal_connect function to specify when it should be called: in this case, when widget b (your button) emits the \"clicked\" signal.","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Using Julia's do syntax, the exact same code could alternatively be written as","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"b = GtkButton(\"Press me\")\nwin = GtkWindow(b, \"Callbacks\")\nid = signal_connect(b, \"clicked\") do widget\n     println(widget, \" was clicked!\")\nend","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"If you try this, and click on the button, you should see something like the following:","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"julia> GtkButton(action-name=NULL, action-target, related-action, use-action-appearance=TRUE, name=\"\", parent, width-request=-1, height-request=-1, visible=TRUE, sensitive=TRUE, app-paintable=FALSE, can-focus=TRUE, has-focus=TRUE, is-focus=TRUE, can-default=FALSE, has-default=FALSE, receives-default=TRUE, composite-child=FALSE, style, events=0, no-show-all=FALSE, has-tooltip=FALSE, tooltip-markup=NULL, tooltip-text=NULL, window, double-buffered=TRUE, halign=GTK_ALIGN_FILL, valign=GTK_ALIGN_FILL, margin-left=0, margin-right=0, margin-top=0, margin-bottom=0, margin=0, hexpand=FALSE, vexpand=FALSE, hexpand-set=FALSE, vexpand-set=FALSE, expand=FALSE, border-width=0, resize-mode=GTK_RESIZE_PARENT, child, label=\"Press me\", image, relief=GTK_RELIEF_NORMAL, use-underline=TRUE, use-stock=FALSE, focus-on-click=TRUE, xalign=0.500000, yalign=0.500000, image-position=GTK_POS_LEFT, ) was clicked!","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"That's quite a lot of output; let's just print the label of the button:","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"id2 = signal_connect(b, \"clicked\") do widget\n    println(\"\\\"\", get_gtk_property(widget,:label,String), \"\\\" was clicked!\")\nend","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Now you get something like this:","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"julia> GtkButton(action-name=NULL, action-target, related-action, use-action-appearance=TRUE, name=\"\", parent, width-request=-1, height-request=-1, visible=TRUE, sensitive=TRUE, app-paintable=FALSE, can-focus=TRUE, has-focus=TRUE, is-focus=TRUE, can-default=FALSE, has-default=FALSE, receives-default=TRUE, composite-child=FALSE, style, events=0, no-show-all=FALSE, has-tooltip=FALSE, tooltip-markup=NULL, tooltip-text=NULL, window, double-buffered=TRUE, halign=GTK_ALIGN_FILL, valign=GTK_ALIGN_FILL, margin-left=0, margin-right=0, margin-top=0, margin-bottom=0, margin=0, hexpand=FALSE, vexpand=FALSE, hexpand-set=FALSE, vexpand-set=FALSE, expand=FALSE, border-width=0, resize-mode=GTK_RESIZE_PARENT, child, label=\"Press me\", image, relief=GTK_RELIEF_NORMAL, use-underline=TRUE, use-stock=FALSE, focus-on-click=TRUE, xalign=0.500000, yalign=0.500000, image-position=GTK_POS_LEFT, ) was clicked!\n\"Press me\" was clicked!","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Notice that both of the callback functions executed! Gtk+ allows you to define multiple signal handlers for a given object; even the execution order can be specified. Callbacks for some signals require that you return an Int32, with value 0 if you want the next handler to run or 1 if you want to prevent any other handlers from running on this event.","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"The \"clicked\" signal callback should return nothing (void in C parlance), so you can't prevent other callbacks from running. However, we can disconnect the first signal handler:","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"signal_handler_disconnect(b, id)","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Now clicking on the button just yields","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"julia> \"Press me\" was clicked!","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Alternatively, you can temporarily enable or disable individual handlers with signal_handler_block and signal_handler_unblock.","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"The arguments of the callback depend on the signal type. For example, instead of using the \"clicked\" signal–-for which the Julia handler should be defined with just a single argument–-we could have used \"button-press-event\":","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"b = GtkButton(\"Pick a mouse button\")\nwin = GtkWindow(b, \"Callbacks\")\nid = signal_connect(b, \"button-press-event\") do widget, event\n    println(\"You pressed button \", event.button)\nend","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"Note that this signal requires two arguments, here widget and event, and that event contained useful information. Arguments and their meaning are described along with their corresponding signals. You should omit the final user_data argument described in the Gtk documentation; keep in mind that you can always address other variables from inside your function block, or define the callback in terms of an anonymous function:","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"id = signal_connect((widget, event) -> cb_buttonpressed(widget, event, guistate, drawfunction, ...), b, \"button-press-event\")","category":"page"},{"location":"manual/signals/#","page":"Signals and Callbacks","title":"Signals and Callbacks","text":"In some situations you may want or need to use an approach that is more analogous to julia's @cfunction callback syntax. One advantage of this alternative approach is that, in cases of error, the backtraces are much more informative.","category":"page"},{"location":"manual/slider/#Slider-widgets-(aka-GtkScale)-and-dynamic-adjustments-1","page":"Slider widgets (aka GtkScale) and dynamic adjustments","title":"Slider widgets (aka GtkScale) and dynamic adjustments","text":"","category":"section"},{"location":"manual/slider/#","page":"Slider widgets (aka GtkScale) and dynamic adjustments","title":"Slider widgets (aka GtkScale) and dynamic adjustments","text":"The following example creates two sliders using GtkScale. The callback function for the 1st slider dynamically changes the value of the 2nd slider to force it to match, and also dynamically changes the range of the 1st slider if the value reaches 10.","category":"page"},{"location":"manual/slider/#","page":"Slider widgets (aka GtkScale) and dynamic adjustments","title":"Slider widgets (aka GtkScale) and dynamic adjustments","text":"This example illustrates that one can use GAccessor.value both to access a widget value and to alter that value.","category":"page"},{"location":"manual/slider/#","page":"Slider widgets (aka GtkScale) and dynamic adjustments","title":"Slider widgets (aka GtkScale) and dynamic adjustments","text":"using Gtk: GtkGrid, GtkScale, GtkWindow, GAccessor\nusing Gtk: signal_connect, set_gtk_property!, showall\n\nwin = GtkWindow(\"Sliders\", 500, 200)\nslider1 = GtkScale(false, 0:10)\nslider2 = GtkScale(false, 0:30)\nsignal_connect(slider1, \"value-changed\") do widget, others...\n    value = GAccessor.value(slider1)\n    GAccessor.value(slider2, value) # dynamic value adjustment\n    println(\"slider value is $value\")\n    if value == 10\n        GAccessor.range(slider1, 1, 20) # dynamic range adjustment\n    end\nend\ng = GtkGrid()\ng[1,1] = slider1\ng[1,2] = slider2\nset_gtk_property!(g, :column_homogeneous, true)\npush!(win, g)\nshowall(win)","category":"page"},{"location":"manual/filedialogs/#Dialogs-1","page":"Dialogs","title":"Dialogs","text":"","category":"section"},{"location":"manual/filedialogs/#File-Dialogs-1","page":"Dialogs","title":"File Dialogs","text":"","category":"section"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"Gtk.jl supports the GtkFileChooserDialog and the GtkFileChooserNative. It also provides four functions, open_dialog and save_dialog as well as open_dialog_native and save_dialog_native, making this functionality easier to use. The syntax of these four functions are as follows:","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"open_dialog(title, GtkNullContainer(), String[])\nsave_dialog(title, GtkNullContainer(), String[])\nopen_dialog_native(title, GtkNullContainer(), String[])\nsave_dialog_native(title, GtkNullContainer(), String[])","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"If you are using these functions in the context of a GUI, you should set the parent to be the top-level window. Otherwise, for standalone usage in scripts, do not set the parent.","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"The main flexibility comes from the filters, which can be specified as a Tuple or Vector. A filter can be specified as a string, in which case it specifies a globbing pattern, for example \"*.png\". You can specify multiple match types for a single filter by separating the patterns with a comma, for example \"*.png,*.jpg\". You can alternatively specify MIME types, or if no specification is provided it defaults to types supported by GdkPixbuf. The generic specification of a filter is","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"GtkFileFilter(; name = nothing, pattern = \"\", mimetype = \"\")","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"If on the other hand you want to choose a folder instead of a file, set the action to GtkFileChooserAction.SELECT_FOLDER:","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"dir = open_dialog(\"Select Dataset Folder\", action=GtkFileChooserAction.SELECT_FOLDER)\nif isdir(dir)\n   # do something with dir\nend","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"Here are some examples:","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"open_dialog(\"Pick a file\")\nopen_dialog(\"Pick some files\", select_multiple=true)\nopen_dialog(\"Pick a file\", Null(), (\"*.jl\",))\nopen_dialog(\"Pick some text files\", GtkNullContainer(), (\"*.txt, *.csv\",), select_multiple=true)\nopen_dialog(\"Pick a file\", Null(), (GtkFileFilter(mimetype=\"text/csv\"),))\nopen_dialog(\"Pick an image file\", GtkNullContainer(), (\"*.png\", \"*.jpg\", GtkFileFilter(\"*.png, *.jpg\", name=\"All supported formats\")))\nopen_dialog(\"Pick an image file\", GtkNullContainer(), (GtkFileFilter(name=\"Supported image formats\"),))\n\nsave_dialog(\"Save as...\", Null(), (GtkFileFilter(\"*.png, *.jpg\", name=\"All supported formats\"), \"*.png\", \"*.jpg\"))","category":"page"},{"location":"manual/filedialogs/#Message-dialogs-1","page":"Dialogs","title":"Message dialogs","text":"","category":"section"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"Gtk.jl also supports GtkMessageDialog and provides several convenience functions:  info_dialog, ask_dialog, warn_dialog, and error_dialog.  Each inputs a string and an optional parent container, and returns nothing, except for ask_dialog which returns true if the user clicked yes.","category":"page"},{"location":"manual/filedialogs/#","page":"Dialogs","title":"Dialogs","text":"info_dialog(\"Julia rocks!\")\nask_dialog(\"Do you like chocolate ice cream?\", \"Not at all\", \"I like it\") && println(\"That's my favorite too.\")\nwarn_dialog(\"Oops!... I did it again\")","category":"page"},{"location":"manual/layout/#Layout-1","page":"Layout","title":"Layout","text":"","category":"section"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"You will usually want to add more than one widget to you application. To this end, Gtk provides several layout widgets. Instead of using a precise positioning, the Gtk layout widgets take an approach where widgets are aligned in boxes and tables.","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"note: Note\nWhile doing the layout using Julia code is possible for small examples it is in general advised to instead create the layout using Glade in combination with GtkBuilder Builder and Glade.","category":"page"},{"location":"manual/layout/#Box-1","page":"Layout","title":"Box","text":"","category":"section"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"The most simple layout widget is the GtkBox. It can be either be horizontally or vertical aligned. It allow to add an arbitrary number of widgets.","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"win = GtkWindow(\"New title\")\nhbox = GtkBox(:h)  # :h makes a horizontal layout, :v a vertical layout\npush!(win, hbox)\ncancel = GtkButton(\"Cancel\")\nok = GtkButton(\"OK\")\npush!(hbox, cancel)\npush!(hbox, ok)\nshowall(win)","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"We can address individual \"slots\" in this container:","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"julia> length(hbox)\n2\n\njulia> get_gtk_property(hbox[1], :label, String)\n\"Cancel\"\n\njulia> get_gtk_property(hbox[2], :label, String)\n\"OK\"","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"This layout may not be exactly what you'd like. Perhaps you'd like the ok button to fill the available space, and to insert some blank space between them:","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"set_gtk_property!(hbox,:expand,ok,true)\nset_gtk_property!(hbox,:spacing,10)","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"The first line sets the expand property of the ok button within the hbox container.","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"Note that these aren't evenly-sized, and that doesn't change if we set the cancel button's expand property to true. ButtonBox is created specifically for this purpose, so let's use it instead:","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"destroy(hbox)\nok = GtkButton(\"OK\")\ncancel = GtkButton(\"Cancel\")\nhbox = GtkButtonBox(:h)\npush!(win, hbox)\npush!(hbox, cancel)\npush!(hbox, ok)\nshowall(win)","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"Now we get this:","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"(Image: window)","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"which may be closer to what you had in mind.","category":"page"},{"location":"manual/layout/#Grid-1","page":"Layout","title":"Grid","text":"","category":"section"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"More generally, you can arrange items in a grid:","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"win = GtkWindow(\"A new window\")\ng = GtkGrid()\na = GtkEntry()  # a widget for entering text\nset_gtk_property!(a, :text, \"This is Gtk!\")\nb = GtkCheckButton(\"Check me!\")\nc = GtkScale(false, 0:10)     # a slider\n\n# Now let's place these graphical elements into the Grid:\ng[1,1] = a    # Cartesian coordinates, g[x,y]\ng[2,1] = b\ng[1:2,2] = c  # spans both columns\nset_gtk_property!(g, :column_homogeneous, true)\nset_gtk_property!(g, :column_spacing, 15)  # introduce a 15-pixel gap between columns\npush!(win, g)\nshowall(win)","category":"page"},{"location":"manual/layout/#","page":"Layout","title":"Layout","text":"The g[x,y] = obj assigns the location to the indicated x,y positions in the grid (note that indexing is Cartesian rather than row/column; most graphics packages address the screen using Cartesian coordinates where 0,0 is in the upper left). A range is used to indicate a span of grid cells. By default, each row/column will use only as much space as required to contain the objects, but you can force them to be of the same size by setting properties like column_homogeneous.","category":"page"},{"location":"manual/builder/#Builder-and-Glade-1","page":"Builder and Glade","title":"Builder and Glade","text":"","category":"section"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"Until now we have created and arranged all widgets entirely using Julia code. While this works fine for small examples, it has the issue that we are tightly coupling the appearance from our application with the logic of our program code. In addition the linear way of procedural Julia code does not fit very well with complex user interfaces arranged in deeply nested tables and boxes.","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"Fortunately, there is a much better way to design user interfaces that strictly separate the layout from the code. This is done by an XML based file format that allows for describing any widget arrangements. The XML file is usually not manually created but designed graphically using Glade in a WYSIWYG (what you see is what you get) manner. In order to use the interface in your Julia Gtk application you will need GtkBuilder.","category":"page"},{"location":"manual/builder/#Glade-1","page":"Builder and Glade","title":"Glade","text":"","category":"section"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"Glade lets you create complex user interfaces by graphically arranging them together in a user friendly way. There are many good tutorials out there so that we will skip a detailed introduction here.","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"The important thing when putting together the interface with glade is to give each widget that you later want to interface with a meaningful ID.","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"note: Note\nNote that Glade can not only be used to create toplevel widgets (e.g. Windows). Instead one can start for instance with a GtkGrid or GtkBox serving as the base for a Custom/Composed Widgets.","category":"page"},{"location":"manual/builder/#Builder-1","page":"Builder and Glade","title":"Builder","text":"","category":"section"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"Once we have created the interface with Glade the result can be stored in an XML file that usually has the extension .glade. Lets assume we have created a file myapp.glade that looks like","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<interface>\n  <!-- interface-requires gtk+ 3.0 -->\n  <object class=\"GtkWindow\" id=\"window1\">\n    <property name=\"can_focus\">False</property>\n    <child>\n      <object class=\"GtkButton\" id=\"button1\">\n        <property name=\"label\" translatable=\"yes\">button</property>\n        <property name=\"use_action_appearance\">False</property>\n        <property name=\"visible\">True</property>\n        <property name=\"can_focus\">True</property>\n        <property name=\"receives_default\">True</property>\n        <property name=\"use_action_appearance\">False</property>\n      </object>\n    </child>\n  </object>\n</interface>","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"In order to access the widgets from Julia we first create a GtkBuilder object that will serve as our connector between the XML definition and our Julia code.","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"b = GtkBuilder(filename=\"path/to/myapp.glade\")","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"Alternatively, if we would store above XML definition in a Julia string myapp we can initalize the builder by","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"b = GtkBuilder(buffer=myapp)","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"Now we want to access a widget from the XML file in order to actually display it on the screen. To do so we call","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"win = b[\"window1\"]\nshowall(win)","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"That is all that you need to know. You can thus see your builder as a kind of a widget store that you use when you need access to your widgets. It it therefore not really necessary to bind the widgets to local variables anymore but instead you can always use the builder object.","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"note: Note\nIf you are developing the code in a package you can get the package directory using the Pkg.dir(\"MyPackage\") function. This allows you to put the files into the package directory and reference them in a relative manner.","category":"page"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"note: Note\nFrom Julia 1.0 on, Pkg.dir() is deprecated. Instead, you can use the @__DIR__ macro. For instance, if your glade file is located at MyPackage/src/builder/myuifile.ui, you can get the full path using uifile = joinpath(@__DIR__, \"builder\", \"myuifile.ui\").","category":"page"},{"location":"manual/builder/#Callbacks-1","page":"Builder and Glade","title":"Callbacks","text":"","category":"section"},{"location":"manual/builder/#","page":"Builder and Glade","title":"Builder and Glade","text":"The XML file lets us only describe the visual structure of our widgets and not their behavior when the using is interacting with it. For this reason, we will have to add callbacks to the widgets which we do in Julia code as it was described in Signals and Callbacks.","category":"page"},{"location":"doc/developer/#Gtk-Developer-Oriented-Documentation:-Extending-Gtk.jl’s-functionality-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"","category":"page"},{"location":"doc/developer/#Implementing-New-Gtk-Types-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Implementing New Gtk Types","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"You can subclass an existing Gtk type in Julia using the following code pattern:","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"type MyWidget <: Gtk.GtkButton\n    handle::Ptr{Gtk.GObject}\n    other_fields\n    function MyWidget(label)\n        btn = @GtkButton(label)\n        Gtk.gobject_move_ref(new(btn), btn)\n    end\nend","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"This creates a MyWidget type which inherits its behavior from GtkButton. The gobject_move_ref call transfers ownership of the GObject handle from GtkButton to MyWidget in a gc-safe manner. Afterwards, the btn object is invalid and converting from the Ptr{GtkObject} to GtkObject will return the MyWidget object.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"New native Gtk types can be most easily added by invoking the Gtk.@GTypes macro:","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":" Gtk.@GTypes GTypeName library_variable sym_name\n Gtk.@GTypes GTypeName library_variable gtyp_getter_expr","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"and then defining the appropriate outer constructors. Note that the @GTypes macro expects a variable suffix to be defined in the current module, which will be appended to the name of the type to create a unique type instance.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Please pay attention to existing constructors that already exist to avoid user confusion: for example, the first argument to a GtkContainer may optionally be its first child widget. And keyword arguments are reserved for setting properties after construction.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"","category":"page"},{"location":"doc/developer/#Utility-functions-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Utility functions","text":"","category":"section"},{"location":"doc/developer/#GLib.bytestring(ptr,-own::Bool)-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"GLib.bytestring(ptr, own::Bool)","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"This no-copy variant of bytestring allows you to specify whether Julia \"owns\" the memory pointed to by ptr (similar to Base.pointer_to_array). This is useful for GList iteration when wishing to return strings created by a Gtk object, and other APIs that return a newly allocated string.","category":"page"},{"location":"doc/developer/#GLib.gc_ref(x::ANY)-/-GLib.gc_unref(x::ANY)-/-GLib.gobject_ref(x::GObject)-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"GLib.gc_ref(x::ANY) / GLib.gc_unref(x::ANY) / GLib.gobject_ref(x::GObject)","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"As the names suggests, these functions increase / decrease the reference count of a Julia object x, to prevent garbage-collection of this object while it is in use by Glib. Note that GLib.gc_unref(w::GObject) should typically not be called, since it will immediately destroy the Julia reference w, and will be called automatically by the Julia garbage-collector once their are no remaining references to this object (in GLib or Julia). The function gc_ref returns a pointer to the gc-protected memory (as a *jl_value_t / Ptr{Nothing}) for use in ccall, whereas gobject_ref returns x for use in method chaining.","category":"page"},{"location":"doc/developer/#mutable{T}(::Type{T})-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"mutable{T}(::Type{T})","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Creates a new box to contain an reference to an instance of T","category":"page"},{"location":"doc/developer/#mutable(x,-i1)-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"mutable(x, i=1)","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Creates a new box (with optional offset index i==1) initialized to contain x","category":"page"},{"location":"doc/developer/#mutable(x::Union{Ptr,Array,Mutable},-i1)-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"mutable(x::Union{Ptr,Array,Mutable}, i=1)","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Returns the reference to the box, x, optionally offset by index i","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"","category":"page"},{"location":"doc/developer/#GLib.MutableTypes-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"GLib.MutableTypes","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"The GLib.MutableTypes module provides methods for seamlessly working with various forms of boxed immutable (or mutable) objects. An immutable object could be boxed in a Ptr and Array, or an MutableTypes.MutableX singleton wrapper. Therefore, the mutable class helps to seamlessly merge all three into a single interface.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Given a mutable object, the user can extract the data in one of three ways:","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Using [] (getindex) notation is convenient short-hand, but is not defined for pointers\nIf the mutable object reference might be a pointer, instead choose either of the deref or unsafe_load function names. Their behavior is identical for the types in the MutableTypes module, but they might have had different fallback methods added externally.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Updating the value is a mutable object reference can also be done in one of three ways:","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"By passing the mutable object to ccall, with type signature Ptr{T}\nUsing [] = (setindex!) is convenient short-hand notation, but is not defined for pointers\nIf the mutable object reference might be a pointer, instead call unsafe_store!","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"","category":"page"},{"location":"doc/developer/#GLists-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"GLists","text":"","category":"section"},{"location":"doc/developer/#Basic-Usage-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Basic Usage","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Gtk functions that return a GLib.GList can be used in Julia's iteration syntax in the following way:","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"for obj in ccall((:gtk_function_that_returns_a_GList,libgtk),\n        Ptr{_GSList{T}}, (ArgTypes...,), args...)\n    # do something with obj\nend","category":"page"},{"location":"doc/developer/#Return-Type-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Return Type","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"The returned instance obj will be of type eltype(_GSList{T}), where for T you have picked the expected element return type. See below for more details on the storage characteristics for various choices of T","category":"page"},{"location":"doc/developer/#GC-Safety-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"GC Safety","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Depending on where you acquired your GLib.GList, you will need to select the appropriate method to provide seamless garbage-collection integration.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"A naked ptr=Ptr{_GSList{T}} is never garbage-collected by Julia. This is useful when iterating over a GLib.GSList (or GLib.GList) from GLib which still owned by the object [transfer-none]\nWrapping the pointer in a call to GLib.GList(ptr) will free the list when the returned GList object reference is garbage-collected [transfer-container]\nWrapping the pointer instead in a call to glist_iter(ptr) will wrap the list in GC-safe iterator. By contrast to calling GLib.GList(ptr), this method is necessary if the user is unlikely to be able to maintain the a reference to the returned object for the life of the iterator. Instances where this is true include iterators (hence the name), since this function is often used to create iterators: start(x) = glist_iter(get_ptr_to_glist(x)). [transfer-container]\nTo both 2 and 3, you can supply an additional boolean parameter transfer-full, to have Julia also dereference and free the individual elements [transfer-full]\nWARNING: ensure the choice of _GSList vs _GList matches the Gtk API exactly. Using the wrong one will corrupt the GSlice allocator.","category":"page"},{"location":"doc/developer/#Julia-allocated-GLists-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Julia-allocated GLists","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"You can create and manipulate a new doubly-linked GList object from Julia by calling the GList(T) constructor, where T is the eltype of the pointers that you want this list to be able to hold.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"list = GList(Int) # similar to Array(Int,1)\nlist[1]","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"By default, these are allocated as [transfer-full], meaning it will deallocate all of its elements when the list is destroyed. However, like all GList constructors, it takes an transfer_full argument, which can be set to false to have Julia reference it as [tranfer-container].","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"To transfer ownership of the GList, you can extract the GList.handle from list, and the set GList.handle = C_NULL to reset it.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"A GList conforms to the AbstractVector interface, and can be used in most contexts that an Array could be used.","category":"page"},{"location":"doc/developer/#GList-eltype-Representations-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"GList eltype Representations","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"GList{T<:GObject} stores references toGObject`\nGList{T<:Any} stores Julia object references\nGList{T<:Ptr} stores pointers, without alteration\nGList{T<:Number} stores numbers inside the pointer (generally only works with Integer, and size must be <= sizeof(int) == 32 bits)\nGList{T<:Ptr{Number}} stores individually g_malloc-created boxed numerical type objects","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"You can add your own conversions by defining the appropriate eltype  -> return type, GLib.ref_to -> makes a pointer from an object, GLib.deref_to -> makes an object from a pointer, and empty! -> frees the contents of a list object of this type methods (see the bottom of GLib/glist.jl for examples.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"","category":"page"},{"location":"doc/developer/#Adding-new-GValueJulia-auto-conversions-1","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Adding new GValue⇄Julia auto-conversions","text":"","category":"section"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"New GValue-to-Julia conversions can be implemented via the Gtk.make_gvalue(pass_x,as_ctype,to_gtype,with_id,allow_reverse::Bool=true) function. This adds all of the appropriate methods to getindex, setindex!, and gvalue to handle converting this value to and from a GValue.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"pass_x is the Julia type\nas_ctype is the type for ccall\nto_gtype is the name of the g_value_get_* g_value_set_* method to use\nwith_id specifies the type identifier. It must resolve to an Int, but can either be a variable, and Integer, or a tuple of the type name and library where the _get_type function can be called\nallow_reverse specifies whether this entry should be used for auto-unpacking","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Note that this calls Core.eval on its arguments in the current module, so if you want to use a symbol from Gtk (such as Gtk.libgtk, make sure you give the fully qualified name). You will also need to ensure the appropriate convert methods exist to translate from pass_x to as_ctype and back. make_gvalue does a few automatic transformations:","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"if the to_gtype is :string or :static_string, make_gvalue will insert calls to bytestring\nif the to_gtype is :pointer or :boxed, make_gvalue will insert code (a call to Gtk.mutable) that converts from Type -> Ptr{Type} in the setindex! method. Providing a conversion from Ptr{Type} -> Type must be handled by the user.","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"For example:","category":"page"},{"location":"doc/developer/#","page":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","title":"Gtk-Developer-Oriented Documentation: Extending Gtk.jl’s functionality","text":"Gtk.make_gvalue(Gtk.GdkRectangle, Ptr{Gtk.GdkRectangle}, :boxed, (:gdk_rectangle,:(Gtk.libgdk)))\nBase.convert(::Type{Gtk.GdkRectangle}, rect::Ptr{Gtk.GdkRectangle}) = unsafe_load(rect)","category":"page"},{"location":"manual/properties/#Properties-1","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"If you're following along, you probably noticed that creating win caused quite a lot of output:","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"GtkWindowLeaf(name=\"\", parent, width-request=-1, height-request=-1, visible=TRUE, sensitive=TRUE, app-paintable=FALSE, can-focus=FALSE, has-focus=FALSE, is-focus=FALSE, can-default=FALSE, has-default=FALSE, receives-default=FALSE, composite-child=FALSE, style, events=0, no-show-all=FALSE, has-tooltip=FALSE, tooltip-markup=NULL, tooltip-text=NULL, window, double-buffered=TRUE, halign=GTK_ALIGN_FILL, valign=GTK_ALIGN_FILL, margin-left=0, margin-right=0, margin-top=0, margin-bottom=0, margin=0, hexpand=FALSE, vexpand=FALSE, hexpand-set=FALSE, vexpand-set=FALSE, expand=FALSE, border-width=0, resize-mode=GTK_RESIZE_QUEUE, child, type=GTK_WINDOW_TOPLEVEL, title=\"My window\", role=NULL, resizable=TRUE, modal=FALSE, window-position=GTK_WIN_POS_NONE, default-width=-1, default-height=-1, destroy-with-parent=FALSE, hide-titlebar-when-maximized=FALSE, icon, icon-name=NULL, screen, type-hint=GDK_WINDOW_TYPE_HINT_NORMAL, skip-taskbar-hint=FALSE, skip-pager-hint=FALSE, urgency-hint=FALSE, accept-focus=TRUE, focus-on-map=TRUE, decorated=TRUE, deletable=TRUE, gravity=GDK_GRAVITY_NORTH_WEST, transient-for, attached-to, opacity=1.000000, has-resize-grip=TRUE, resize-grip-visible=TRUE, application, ubuntu-no-proxy=FALSE, is-active=FALSE, has-toplevel-focus=FALSE, startup-id, mnemonics-visible=TRUE, focus-visible=TRUE, )","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"This shows you a list of properties of the object. For example, notice that the title property is set to \"My window\". We can change the title in the following way:","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"julia> set_gtk_property!(win, :title, \"New title\")","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"To get the property, you have to specify the return type as a second argument:","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"julia> get_gtk_property(win, :title, String)\n\"New title\"","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"This is necessary because Gtk, a C library, maintains the state; you have to specify what type of Julia object you want to create from the pointers it passes back.","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"To access particular properties, you can either use symbols, like :title, or strings, like \"title\". When using symbols, you'll need to convert any Gtk names that use - into names with _:","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"julia> get_gtk_property(win, :double_buffered, Bool)\ntrue","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"Some properties have convenience methods, for example:","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"julia> visible(win)\ntrue\n\njulia> visible(win, false)\n\njulia> visible(win)\nfalse\n\njulia> visible(win, true)","category":"page"},{"location":"manual/properties/#","page":"Properties","title":"Properties","text":"This sequence makes the window disappear and then reappear.","category":"page"},{"location":"manual/nonreplusage/#Non-REPL-Usage-1","page":"Non REPL Usage","title":"Non REPL Usage","text":"","category":"section"},{"location":"manual/nonreplusage/#","page":"Non REPL Usage","title":"Non REPL Usage","text":"If you're using Gtk from command-line scripts, one problem you may encounter is that Julia quits before you have a chance to see or interact with your windows. In such cases, the following design pattern can be helpful:","category":"page"},{"location":"manual/nonreplusage/#","page":"Non REPL Usage","title":"Non REPL Usage","text":"win = Window(\"gtkwait\")\n\n# Put your GUI code here\n\nif !isinteractive()\n    c = Condition()\n    signal_connect(win, :destroy) do widget\n        notify(c)\n    end\n    @async Gtk.gtk_main()\n    wait(c)\nend","category":"page"},{"location":"manual/nonreplusage/#","page":"Non REPL Usage","title":"Non REPL Usage","text":"By waiting on a Condition, Julia will keep running. This pattern allows for multiple events to trigger the condition, such as a button press, or one of many windows to be closed. Program flow will resume at wait line, after which it would terminate in this example.","category":"page"},{"location":"manual/nonreplusage/#","page":"Non REPL Usage","title":"Non REPL Usage","text":"In the common case we simply wish to wait for a single window to be closed, this can be shortened by using waitforsignal:","category":"page"},{"location":"manual/nonreplusage/#","page":"Non REPL Usage","title":"Non REPL Usage","text":"win = Window(\"gtkwait\")\n\n# Put your GUI code here\n\nif !isinteractive()\n    @async Gtk.gtk_main()\n    Gtk.waitforsignal(win,:destroy)\nend","category":"page"},{"location":"manual/textwidgets/#Text-Widgets-1","page":"Text Widgets","title":"Text Widgets","text":"","category":"section"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"There are two basic widgets available for rendering simple text. The one is for displaying non-editable text GtkLabel the other is for editable text GtkEntry.","category":"page"},{"location":"manual/textwidgets/#Label-1","page":"Text Widgets","title":"Label","text":"","category":"section"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"A GtkLabel is the most basic text widget that has already been used behind the scene in any previous example involving a GtkButton. A GtkLabel is constructed by calling","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"label = GtkLabel(\"My text\")","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"The text of a label can be changed using","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"GAccessor.text(label,\"My other text\")","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"Furthermore, a label has limited support for adding formatted text. This is done using the markup function:","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"GAccessor.markup(label,\"\"\"<b>My bold text</b>\\n\n                          <a href=\\\"https://www.gtk.org\\\"\n                          title=\\\"Our website\\\">GTK+ website</a>\"\"\")","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"The syntax for this markup text is borrowed from html and explained here.","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"A label can be made selectable using","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"GAccessor.selectable(label,true)","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"This can be used if the user should be allowed to copy the text.","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"The justification of a label can be changed in the following way:","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"GAccessor.justify(label,Gtk.GConstants.GtkJustification.RIGHT)","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"Possible values of the enum GtkJustification are LEFT,RIGHT,CENTER, and FILL.","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"Automatic line wrapping can be enabled using","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"GAccessor.text(label,repeat(\"Very long text! \",20))\nGAccessor.line_wrap(label,true)","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"Note that this will only happen, if the size of the widget is limited using layout constraints.","category":"page"},{"location":"manual/textwidgets/#Entry-1","page":"Text Widgets","title":"Entry","text":"","category":"section"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"The entry widget allows the user to enter text. The entered text can be read and write using","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"ent = GtkEntry()\nset_gtk_property!(ent,:text,\"My String\")\nstr = get_gtk_property(ent,:text,String)","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"The maximum number of characters can be limited using set_gtk_property!(ent,:max_length,10).","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"Sometimes you might want to make the widget non-editable. This can be done by a call","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"# using the accessor methods\nGAccessor.editable(GtkEditable(ent),false)\n# using the property system\nset_gtk_property!(ent,:editable,false)","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"If you want to use the entry to retrieve passwords you can hide the visibility of the entered text. This can be achieve by calling","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"set_gtk_property!(ent,:visibility,false)","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"To get notified by changes to the entry one can listen the \"changed\" event.","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"TODO: setting progress and setting icons in entry","category":"page"},{"location":"manual/textwidgets/#Search-Entry-1","page":"Text Widgets","title":"Search Entry","text":"","category":"section"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"A special variant of the entry that can be used as a search box is GtkSearchEntry. It is equipped with a button to clear the entry.","category":"page"},{"location":"manual/textwidgets/#","page":"Text Widgets","title":"Text Widgets","text":"note: Note\nCurrently GtkSearchEntry is not fully wrapped in Gtk.jl but if you add it using Glade, it can be used as an alternative to the `GtkEntry","category":"page"},{"location":"#Gtk.jl-1","page":"Home","title":"Gtk.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Julia Bindings for Gtk.","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Gtk.jl is a is a Julia package providing bindings for the Gtk library: https://www.gtk.org/","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Complete Gtk documentation is available at https://www.gtk.org/docs/","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Install Gtk.jl within Julia using","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Gtk\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"tip: Tip\nOn some platforms, you may see messages likeGtk-Message: 20:15:48.288: Failed to load module \"canberra-gtk-module\"These are harmless. If you want to suppress them, on Unix platforms you can add something likeexport GTK_PATH=$GTK_PATH:/usr/lib/x86_64-linux-gnu/gtk-3.0to your .bashrc file. (You may need to customize the path for your system; it should have a modules directory containing libcanberra.)","category":"page"},{"location":"#Precompilation-1","page":"Home","title":"Precompilation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Gtk is precompilable by normal mechanisms. Julia 1.6 or higher is recommended as having much shorter load times than earlier Julia versions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"On very old Julia versions, you can use PackageCompiler. Be aware that this has downsides and should not be necessary on modern versions of Julia.","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"See Getting Started for an introduction to using the package","category":"page"},{"location":"#Related-packages-1","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Gizmos/GtkObservables is designed to simplify the creation of GUIs using Gtk and Julia.","category":"page"},{"location":"#Attribution-1","page":"Home","title":"Attribution","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Gtk logo is made by Andreas Nilsson [GFDL or CC-BY-SA-3.0], via Wikimedia Commons","category":"page"},{"location":"doc/function_reference/#Objects-1","page":"-","title":"Objects","text":"","category":"section"},{"location":"doc/function_reference/#","page":"-","title":"-","text":"@GtkWindow(title, w=-1, h=-1, resizable=true, toplevel=true)","category":"page"},{"location":"doc/function_reference/#","page":"-","title":"-","text":"Creates a new window. If the width and height are not specified, the library picks a default size.","category":"page"},{"location":"doc/function_reference/#","page":"-","title":"-","text":"<br />","category":"page"},{"location":"doc/function_reference/#","page":"-","title":"-","text":"@GtkFrame(label::String)","category":"page"},{"location":"doc/function_reference/#","page":"-","title":"-","text":"Creates a frame, with an optional text label","category":"page"},{"location":"doc/function_reference/#","page":"-","title":"-","text":"<br />","category":"page"},{"location":"doc/function_reference/#Layout-1","page":"-","title":"Layout","text":"","category":"section"},{"location":"doc/properties/#Gtk-object-properties-1","page":"Gtk object properties","title":"Gtk object properties","text":"","category":"section"},{"location":"doc/properties/#","page":"Gtk object properties","title":"Gtk object properties","text":"Any child object inherits the properties of its parent(s). Not all of these are implemented as objects in this package, but you can still access the properties.","category":"page"},{"location":"doc/properties/#","page":"Gtk object properties","title":"Gtk object properties","text":"Widgets\nContainers\nMulti-object containers:\nBox, a vertical or horizontal container\nGrid (Gtk3 only), a 2d container\nTable, a 2d container\nNotebook, a tabbed container\nPaned, a container for resizing rectangular portions of a GUI\nButtonBox, layout of buttons\nMenuShell, abstract type for menu containers\nMenuBar\nMenu\nSingle-object containers:\nWindow\nFrame, to offset a region (optionally with label)\nAspectFrame, a frame with fixed aspect ratio\nExpander, a container that hides/reveals another widget\nOverlay (Gtk3 only)\nSingle-object \"containers\" with specific GUI function\nButton\nToggleButton\nCheckButton\nRadioButton\nLinkButton, link to a URL\nScaleButton\nVolumeButton, specialized for audio applications\nComboBox, select among dropdown options\nComboBoxText\nMenuItem\nSeparatorMenuItem, to insert a separator between menu items\nStatusbar, queue messages and display to user\nEntry, type short text in a box\nSpinButton, increment/decrement or type a value\nRange, abstract type for visualizing an Adjustment\nScale, slider for setting a value (see also Adjustment)\nProgressBar, progress on task of known duration\nSpinner, progress on task of unknown duration\nMiscellaneous\nLabel, a text label\nImage, an image","category":"page"},{"location":"doc/properties/#","page":"Gtk object properties","title":"Gtk object properties","text":"Other:","category":"page"},{"location":"doc/properties/#","page":"Gtk object properties","title":"Gtk object properties","text":"Adjustment, stores value and range properties","category":"page"},{"location":"doc/properties/#","page":"Gtk object properties","title":"Gtk object properties","text":"Dialogs:","category":"page"},{"location":"doc/properties/#","page":"Gtk object properties","title":"Gtk object properties","text":"FileChooser","category":"page"}]
}
